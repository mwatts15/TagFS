#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "params.h"
#include "tagdb.h"
#include "tagdb_fs.h"
#include "tagdb_util.h"
#include "path_util.h"
#include "fs_util.h"
#include "set_ops.h"
#include "file_log.h"
#include "fs_util.h"
#include "subfs.h"

static file_id_t get_id_number_from_file_name(char *name, char**new_start)
{
    /* Returns 0 if there isn't an ID that can be extracted from the file */
    char *p = strchr(name, ':');
    file_id_t file_id = 0;
    *new_start = name;
    if (p)
    {
        file_id = strtoull(name,NULL,10);
        *new_start = p + 1; /* Put new start on the character after the colon */
    }
    return file_id;
}

int is_directory (const char *path)
{
    int res = FALSE;
    if (g_strcmp0(path, "/") == 0)
    {
        return TRUE;
    }

    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);

    tagdb_key_t path_key = path_extract_key(dir);
    Tag *base_tag = lookup_tag(DB, base);

    if (base_tag != NULL)
    {
        GList *tags = get_tags_list(DB, path_key);

        res = (g_list_find(tags, base_tag) ||
                stage_lookup(STAGE, path_key, base));

        g_list_free(tags);
    }

    key_destroy(path_key);
    g_free(base);
    g_free(dir);
    return res;
}

char *file_realpath (File *f)
{
    return tagfs_realpath_i(get_file_id((AbstractFile*)f));
}

// returns the file in our copies directory corresponding to
// the one in path
// should only be called on regular files since
// directories are only virtual
char *tagfs_realpath_i (file_id_t id)
{
    char *res = g_strdup_printf("%s/%ld", FSDATA->copiesdir, id);
    debug("realpath = \"%s\"", res);
    return res;
}

File *path_to_file (const char *path)
{
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *new_start;
    file_id_t idx = get_id_number_from_file_name(base, &new_start);

    tagdb_key_t key = path_extract_key(dir);
    File *f;
    if (idx != 0)
    {
        f = retrieve_file(DB, idx);
    }
    else
    {
        f = lookup_file(DB, key, new_start);
    }

    key_destroy(key);
    g_free(base);
    g_free(dir);
    return f;
}

// turn the path into a file in the copies directory
// path_to_file_search_string + tagdb_query + file_realpath
// NULL for a file that DNE
char *get_file_copies_path (const char *path)
{
    File *f = path_to_file(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}

/* Translates the path into a NULL-terminated
 * vector of Tag IDs, the key format for our
 * FileTrie
 */
tagdb_key_t path_extract_key (const char *path)
{
    /* Get the path components */
    char **comps = split_path(path);
    tagdb_key_t key = key_new();

    for (int i = 0; comps[i] != NULL; i++)
    {
        debug("path_extract_key:comps[i]=%s\n", comps[i]);
        Tag *t = lookup_tag(DB, comps[i]);
        if (t == NULL)
        {
            warn("path_extract_key t == NULL\n");
            g_strfreev(comps);
            g_free(key);
            return NULL;
        }
        key_push_end(key, tag_id(t));
    }
    g_strfreev(comps);
    return key;
}

%(path_check path)
{
    return TRUE;
}

// Also returns the file object if it is a file
File *is_file (const char *path)
{
    return path_to_file(path);
}

%(op getattr path statbuf)
{
    int retstat = -ENOENT;
    if (is_directory(path))
    {
        statbuf->st_mode = DIR_PERMS;
        retstat = 0;
    }
    else if (is_file(path))
    {
        char *fpath = get_file_copies_path(path);
        debug("getattr:fpath = %s", fpath);
        retstat = lstat(fpath, statbuf);
        debug("getattr:retstat = %d", retstat);
        g_free(fpath);
    }
    return retstat;
}

%(op readlink path realpath bufsize)
{
    char *copies_path = get_file_copies_path(path);
    int retstat = readlink(copies_path, realpath, bufsize);
    g_free(copies_path);
    return retstat;
}

%(op rename path newpath)
{
    int retstat = 0;

    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);

    char *olddir = g_path_get_dirname(path);
    char *newdir = g_path_get_dirname(newpath);
    if (is_directory(path))
    {
        Tag *t = lookup_tag(DB, oldbase);
        if (t)
        {
            if (is_directory(newpath))
            {
                retstat = -1;
                errno = EEXIST;
            }
            else
            {
                set_tag_name(t, newbase, DB);
            }
        }
        else
        {
            retstat = -1;
            errno = ENOENT;
        }
    }
    else
    {
        File *f = path_to_file(path);
        if (f)
        {
            debug("the file is %s", file_name(f));
            char *new_start;
            get_id_number_from_file_name(newbase, &new_start); /* get the part of the file name after an ID */
            set_file_name(f, new_start, DB);
            if (strcmp(olddir, newdir) != 0)
            {
                remove_file(DB, f);
                // remove the tags from the file
                // add new tags with old values or NULL
                TagTable *old_tags = f->tags;

                tagdb_key_t tags = path_extract_key(newdir);

                KL(tags, i)
                {
                    /* look up the value on this tag if there is one. This is to make sure
                     * we don't clobber any values that were previously set for the tag.
                     */
                    debug("rename tags[i] %ld\n", key_ref(tags, i));
                    tagdb_value_t *v = g_hash_table_lookup(old_tags, TO_SP(key_ref(tags,i)));
                    if (!v)
                    {
                        /* If there isn't a value, add the tag with the default value */
                        add_tag_to_file(DB, f, key_ref(tags,i), NULL);
                    }
                } KL_END;
                insert_file(DB, f);
                key_destroy(tags);
            }
        }
        else
        {
            retstat = -1;
            errno = ENOENT;
        }
    }
    g_free(newbase);
    g_free(oldbase);
    g_free(olddir);
    g_free(newdir);
    return retstat;
}

%(op mknod path mode dev)
{

    int retstat = 0;

    char *base = g_path_get_basename(path);

    File *f = new_file(base);
    char *fpath = file_realpath(f);
    /*
       if (S_ISREG(mode)) {
       retstat = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
       if (retstat >= 0)
       retstat = close(retstat);
       }
       else */
    if (S_ISFIFO(mode)) {
        retstat = mkfifo(fpath, mode);
    }
    else
    {
        retstat = mknod(fpath, mode, dev);
    }

    insert_file(DB, f);
    g_free(base);
    g_free(fpath);
    return retstat;
}

%(op create path mode fi)
{
    int retstat = 0;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    /* The "copy index" can't legally start a name.
     * We just strip it so a user can't create it
     */
    char *new_start;
    get_id_number_from_file_name(base, &new_start);
    File *f = new_file(new_start);
    tagdb_key_t tags = path_extract_key(dir);
    if (!tags)
    {
        log_msg("invalid path in creat\n");
        errno = ENOENT;
        return -1;
    }

    KL(tags, i)
    {
        add_tag_to_file(DB, f, key_ref(tags,i), NULL);
    } KL_END;

    insert_file(DB, f);

    char *realpath = file_realpath(f);

    int fd = creat(realpath, mode);
    if (fd)
        fi->fh = fd;
    else
        retstat = -1;

    g_free(base);
    g_free(dir);
    g_free(realpath);
    key_destroy(tags);
    return retstat;
}

%(op mkdir path mode)
{
    %(log)
    int retstat = 0;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *p = NULL;
    get_id_number_from_file_name(base, &p);

    /* if there's any kind of id preceding the file, then we musn't accept it */
    if (base == p)
    {
        Tag *t = lookup_tag(DB, base);
        if (t == NULL)
        {
            // Make a new tag object
            // give it int type with default value 0
            t = new_tag(base, tagdb_int_t, 0);
            // Insert it into the TagDB TagTree
            insert_tag(DB, t);
        }
        tagdb_key_t key = path_extract_key(dir);
        stage_add(STAGE, key, (gpointer)tag_name(t), (AbstractFile*)t);
        key_destroy(key);
    }
    else
    {
        retstat = -1;
        errno = ENOTDIR;
    }
    g_free(base);
    g_free(dir);
    return retstat;
}

%(op rmdir path)
{
    /* Unconditionally removes the tag. References to the tag by id will still exist
     * in the FileCabinet and also in the Files themselves, but they should be
     * systematically ignored by TagDB since the Tag record will no longer show up
     */
    int retstat = -1;
    char *dir = g_path_get_dirname(path);
    char *base = g_path_get_basename(path);
    tagdb_key_t key = path_extract_key(dir);
    tagdb_key_t path_key = path_extract_key(path);
    Tag *t = lookup_tag(DB, base);
    stage_remove(STAGE, key, base);
    if (t)
    {
        /* if any of the files under this tag are homeless, put them in the UNTAGGED folder */
        GList *files = tag_files(DB, t);
        LL (files, it)
        {
            File *f = it->data;
            if (file_is_homeless(DB,f))
            {
                put_file_in_untagged(DB,f);
            }
        }
        delete_tag(DB, t);
        g_list_free(files);
        t = NULL;
        retstat = 0;
    }
    g_free(dir);
    g_free(base);
    key_destroy(key);
    key_destroy(path_key);
    return retstat;
}

%(op unlink path)
{
    int retstat = 0;

    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        if (fpath)
            retstat = unlink(fpath);
        delete_file(DB, f);
        g_free(fpath);
    }

    return retstat;
}

%(op open path f_info)
{
    int retstat = 0;
    int fd;

    // get the file id from the search path if necessary and get
    // the realpath from the id
    char *fpath = get_file_copies_path(path);
    fd = open(fpath, f_info->flags);
    g_free(fpath);

    f_info->fh = fd;
    log_fi(f_info);
    return retstat;
}

%(op write path buf size offset fi)
{
    %(log)
    return file_info_write(fi, buf, size, offset);
}

%(op truncate path newsize)
{
    %(log)
    int retstat = 0;

    char *fpath = get_file_copies_path(path);

    if (fpath != NULL)
    {
        retstat = truncate(fpath, newsize);
        if (retstat < 0)
            log_error("tagfs_truncate truncate");
    }

    g_free(fpath);
    return retstat;
}

%(op ftruncate path size fi)
{
    %(log)
    return file_info_truncate(fi, size);
}

%(op read path buffer size offset f_info)
{
    %(log)
    return file_info_read(f_info, buffer, size, offset);
}

%(op fsync path datasync f_info)
{
    %(log)
    return file_info_fsync(f_info, datasync);
}

%(op chmod path mode)
{
    char *file_realpath = get_file_copies_path(path);
    int res = chmod(file_realpath, mode);
    g_free(file_realpath);
    return res;
}

%(op chown path uid gid)
{
    char *file_realpath = get_file_copies_path(path);
    int res = chown(file_realpath, uid, gid);
    g_free(file_realpath);
    return res;
}


%(op readdir path buffer filler offset f_info)
{
    int res = 0;
    GList *f = NULL;
    GList *t = NULL;
    GHashTable* seen = NULL;
    GList *s = NULL;

    GList *combined_tags = NULL;
    char fname[MAX_FILE_NAME_LENGTH];
    const char *le_name = NULL;

    tagdb_key_t tags = path_extract_key(path);

    if (g_strcmp0(path, "/") == 0)
    {
        f = tagdb_untagged_items(DB);
        t = g_hash_table_get_values(DB->tags);
    }
    else
    {
        f = get_files_list(DB, tags);
        t = get_tags_list(DB, tags);
    }


    if (tags)
    {
        s = stage_list_position(STAGE, tags);
    }

    LL(f, it)
    {
        le_name = file_to_string(it->data,fname);
        if (filler(buffer, le_name, NULL, 0))
        {
            log_msg("    ERROR tagfs_readdir filler:  buffer full");
            res = -1;
            goto READDIR_END;
        }
    } LL_END;

    combined_tags = g_list_concat(t, s);
    seen = g_hash_table_new(g_direct_hash, g_direct_equal);
    LL(combined_tags, it)
    {
        if (!g_hash_table_lookup(seen, it->data))
        {
            le_name = tag_name(it->data);
            if (filler(buffer, le_name, NULL, 0))
            {
                log_msg("    ERROR tagfs_readdir filler:  buffer full");
                res = -1;
                goto READDIR_END;
            }
            g_hash_table_insert(seen, it->data, it->data);
        }
    } LL_END;

    READDIR_END:
    g_hash_table_destroy(seen);
    key_destroy(tags);
    g_list_free(f);
    g_list_free(combined_tags);
    return res;
}

%(subfs_component)
