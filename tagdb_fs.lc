#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "params.h"
#include "tagdb.h"
#include "tagdb_fs.h"
#include "tagdb_util.h"
#include "path_util.h"
#include "fs_util.h"
#include "set_ops.h"
#include "file_log.h"
#include "fs_util.h"
#include "subfs.h"

static guint get_id_number_from_file_name(char *name, char**new_start)
{
    char *p = strchr(name, ':');
    guint file_id = 0;
    *new_start = name;
    if (p)
    {
        file_id = strtoul(name,NULL,10);
        *new_start = p + 1;
    }
    return file_id;
}

int is_directory (const char *path)
{
    int res = FALSE;
    if (g_strcmp0(path, "/") == 0)
    {
        return TRUE;
    }

    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);

    tagdb_key_t path_key = path_extract_key(dir);
    print_key(path_key);
    Tag *base_tag = lookup_tag(DB, base);

    if (base_tag != NULL)
    {
        printf("base_tag->name == '%s'\n", tag_name(base_tag));
        GList *tags = get_tags_list(DB, path_key);

        res = (g_list_find(tags, base_tag) ||
                stage_lookup(STAGE, path_key, base));

        g_list_free(tags);
    }

    key_destroy(path_key);
    g_free(base);
    g_free(dir);
    return res;
}

char *file_realpath (File *f)
{
    return tagfs_realpath_i(get_file_id((AbstractFile*)f));
}

File *path_to_file (const char *path)
{
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *new_start;
    guint idx = get_id_number_from_file_name(base, &new_start);

    tagdb_key_t key = path_extract_key(dir);
    File *f;
    if (idx != 0)
    {
        f = retrieve_file(DB, idx);
    }
    else
    {
        f = lookup_file(DB, key, new_start);
    }

    key_destroy(key);
    g_free(base);
    g_free(dir);
    return f;
}

// turn the path into a file in the copies directory
// path_to_file_search_string + tagdb_query + file_realpath
// NULL for a file that DNE
char *get_file_copies_path (const char *path)
{
    File *f = path_to_file(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}

/* Translates the path into a NULL-terminated
 * vector of Tag IDs, the key format for our
 * FileTrie
 */
tagdb_key_t path_extract_key (const char *path)
{
    /* Get the path components */
    char **comps = split_path(path);
    tagdb_key_t key = key_new();

    for (int i = 0; comps[i] != NULL; i++)
    {
        log_msg("path component: %s\n", comps[i]);
        Tag *t = lookup_tag(DB, comps[i]);
        if (t == NULL)
        {
            log_msg("path_extract_key t == NULL\n");
            g_strfreev(comps);
            g_free(key);
            return NULL;
        }
        key_push_end(key, get_file_id((AbstractFile*)t));
    }
    g_strfreev(comps);
    return key;
}

%(path_check path)
{
    printf("checking validity of path for tagdb_fs\n");
    return TRUE;
}

// Also returns the file object if it is a file
File *is_file (const char *path)
{
    return path_to_file(path);
}

%(op getattr path statbuf)
{
    int retstat = -ENOENT;
    if (is_directory(path))
    {
        printf("IT IS A DIRECTORY %s\n", path);
        statbuf->st_mode = DIR_PERMS;
        retstat = 0;
    }
    else if (is_file(path))
    {
        char *fpath = get_file_copies_path(path);
        retstat = lstat(fpath, statbuf);
        g_free(fpath);
    }
    return retstat;
}

%(op readlink path realpath bufsize)
{
    char *copies_path = get_file_copies_path(path);
    int retstat = readlink(copies_path, realpath, bufsize);
    g_free(copies_path);
    return retstat;
}

%(op rename path newpath)
{
    int retstat = 0;

    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);

    char *olddir = g_path_get_dirname(path);
    char *newdir = g_path_get_dirname(newpath);
    if (is_directory(path))
    {
        Tag *t = lookup_tag(DB, oldbase);
        if (t)
        {
            if (is_directory(newpath))
            {
                retstat = -1;
                errno = EEXIST;
            }
            else
            {
                set_tag_name(t, newbase, DB);
            }
        }
        else
        {
            retstat = -1;
            errno = ENOENT;
        }
    }
    else
    {
        File *f = path_to_file(path);
        if (f)
        {
            int untagging = 0;
            char *new_start;
            get_id_number_from_file_name(newbase, &new_start);
            set_file_name(f, new_start, DB);
            remove_file(DB, f);
            // remove the tags from the file
            // add new tags with old values or NULL
            TagTable *old_tags = f->tags;

            if (g_str_has_suffix(newdir, UNTAG_FH))
            {
                untagging = TRUE;
                char *tmp = newdir;
                newdir = g_path_get_dirname(newdir);
                g_free(tmp);
            }

            tagdb_key_t tags = path_extract_key(newdir);

            KL(tags, i)
            {
                if (untagging)
                {
                    /* Remove a tag from the file which is in this path */
                    remove_tag_from_file(DB, f, key_ref(tags,i));
                }
                else
                {
                    /* look up the value on this tag if there is one */
                    tagdb_value_t *v = g_hash_table_lookup(old_tags, TO_SP(key_ref(tags,i)));
                    if (!v)
                    {
                        /* If there isn't a value, add the tag with the default value */
                        add_tag_to_file(DB, f, key_ref(tags,i), NULL);
                    }
                }
            } KL_END;
            insert_file(DB, f);
            key_destroy(tags);
        }
    }
    g_free(newbase);
    g_free(oldbase);
    g_free(olddir);
    g_free(newdir);
    return retstat;
}

%(op mknod path mode dev)
{

    int retstat = 0;

    char *base = g_path_get_basename(path);

    File *f = new_file(base);
    char *fpath = file_realpath(f);
    /*
       if (S_ISREG(mode)) {
       retstat = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
       if (retstat >= 0)
       retstat = close(retstat);
       }
       else */
    if (S_ISFIFO(mode)) {
        retstat = mkfifo(fpath, mode);
    }
    else
    {
        retstat = mknod(fpath, mode, dev);
    }

    insert_file(DB, f);
    g_free(base);
    g_free(fpath);
    return retstat;
}

%(op create path mode fi)
{
    int retstat = 0;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    /* The "copy index" can't legally start a name.
     * We just strip it so a user can't create it
     */
    char *new_start;
    get_id_number_from_file_name(base, &new_start);
    File *f = new_file(new_start);
    tagdb_key_t tags = path_extract_key(dir);
    if (!tags)
    {
        log_msg("invalid path in creat\n");
        errno = ENOENT;
        return -1;
    }

    KL(tags, i)
    {
        add_tag_to_file(DB, f, key_ref(tags,i), NULL);
    } KL_END;
    insert_file(DB, f);

    char *realpath = file_realpath(f);

    int fd = creat(realpath, mode);
    if (fd)
        fi->fh = fd;
    else
        retstat = -1;

    g_free(base);
    g_free(dir);
    key_destroy(tags);
    return retstat;
}

%(op mkdir path mode)
{
    %(log)
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);

    Tag *t = lookup_tag(DB, base);
    if (t == NULL)
    {
        // Make a new tag object
        // give it int type with default value 0
        t = new_tag(base, tagdb_int_t, 0);
        // Insert it into the TagDB TagTree
        insert_tag(DB, t);
    }
    tagdb_key_t key = path_extract_key(dir);
    printf(__FILE__ " mkdir key = ");
    print_key(key);
    log_msg("%p", key);
    stage_add(STAGE, key, (gpointer)tag_name(t), (AbstractFile*)t);
    key_destroy(key);
    g_free(base);
    g_free(dir);
    return 0;
}

%(op rmdir path)
{
    /* Every file tagged with base name tag will have all tags in the
       dirname of the path removed from it.

       Essentially, it's what would happen if you called unlink on all of
       the files within seperately

       Calling rmdir on a tag with no files associated with it actually
       deletes the tag.
    */
    int retstat = -1;
    char *dir = g_path_get_dirname(path);
    char *base = g_path_get_basename(path);
    tagdb_key_t key = path_extract_key(path);
    Tag *t = lookup_tag(DB, base);
    if (t)
    {
        remove_tag(DB, t);
        retstat = 0;
    }
    stage_remove(STAGE, key, base);
    g_free(dir);
    g_free(base);
    key_destroy(key);
    return retstat;
}

%(op unlink path)
{
    int retstat = 0;
    //char *dir = g_path_get_dirname(path);
    //char *base = g_path_get_basename(path);

    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        if (fpath)
            retstat = unlink(fpath);
        delete_file(DB, f);
        g_free(fpath);
    }

    return retstat;
}

%(op open path f_info)
{
    int retstat = 0;
    int fd;

    // get the file id from the search path if necessary and get
    // the realpath from the id
    char *fpath = get_file_copies_path(path);
    fd = open(fpath, f_info->flags);
    g_free(fpath);

    f_info->fh = fd;
    log_fi(f_info);
    return retstat;
}

%(op write path buf size offset fi)
{
    %(log)
    return file_info_write(fi, buf, size, offset);
}

%(op truncate path newsize)
{
    %(log)
    int retstat = 0;

    char *fpath = get_file_copies_path(path);

    if (fpath != NULL)
    {
        retstat = truncate(fpath, newsize);
        if (retstat < 0)
            log_error("tagfs_truncate truncate");
    }

    g_free(fpath);
    return retstat;
}

%(op ftruncate path size fi)
{
    %(log)
    return file_info_truncate(fi, size);
}

%(op read path buffer size offset f_info)
{
    %(log)
    return file_info_read(f_info, buffer, size, offset);
}

%(op fsync path datasync f_info)
{
    %(log)
    return file_info_fsync(f_info, datasync);
}

%(op chmod path mode)
{
    char *file_realpath = get_file_copies_path(path);
    int res = chmod(file_realpath, mode);
    g_free(file_realpath);
    return res;
}

%(op chown path uid gid)
{
    char *file_realpath = get_file_copies_path(path);
    int res = chown(file_realpath, uid, gid);
    g_free(file_realpath);
    return res;
}


%(op readdir path buffer filler offset f_info)
{
    int res = 0;
    GList *f = NULL;
    GList *t = NULL;

    tagdb_key_t tags = path_extract_key(path);
    if (g_strcmp0(path, "/") == 0)
    {
        f = tagdb_untagged_items(DB);
        t = g_hash_table_get_values(DB->tags);
    }
    else
    {
        f = get_files_list(DB, tags);
        t = get_tags_list(DB, tags);
    }


    GList *s = NULL;
    if (tags)
    {
        printf("getting the stage tags\n");
        s = stage_list_position(STAGE, tags);
        printf("got the stage tags\n");
    }

    printf("about to combine tags\n");
    GList *combined_tags = g_list_union(s, t, (GCompareFunc) file_name_cmp);
    printf("combined tags\n");
    char fname[MAX_FILE_NAME_LENGTH];
    const char *le_name = NULL;
    printf("About to list files...\n");
    LL(f, it)
    {
        le_name = file_to_string(it->data,fname);
        printf("listing file %s\n", le_name);
        if (filler(buffer, le_name, NULL, 0))
        {
            log_msg("    ERROR tagfs_readdir filler:  buffer full");
            res = -1;
            goto READDIR_END;
        }
    } LL_END;

    printf("About to list tags...\n");
    LL(combined_tags, it)
    {
        le_name = tag_name(it->data);
        printf("listing directory %s\n", le_name);
        if (filler(buffer, le_name, NULL, 0))
        {
            log_msg("    ERROR tagfs_readdir filler:  buffer full");
            res = -1;
            goto READDIR_END;
        }
    } LL_END;

    READDIR_END:
    key_destroy(tags);
    g_list_free(f);
    g_list_free(t);
    g_list_free(s);
    g_list_free(combined_tags);
    return res;
}

%(subfs_component)
