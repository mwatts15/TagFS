#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <attr/xattr.h>
#include <assert.h>
#include "params.h"
#include "util.h"
#include "tagdb.h"
#include "tagdb_fs.h"
#include "tagdb_util.h"
#include "path_util.h"
#include "fs_util.h"
#include "set_ops.h"
#include "file_log.h"
#include "fs_util.h"
#include "log.h"
#include "subfs.h"

typedef struct {
    int fd;
    File *fp;
} _FileHandle;

_FileHandle *file_handle_new(int fd, File *fp);
void file_handle_destroy(_FileHandle*);
int _prepare_signal(const char *signal, const int max_tries);
void _send_tag_signal (const char *signal, file_id_t tid, const char *name);
void _send_file_signal(const char *signal, file_id_t fid, const char *path);
#define TO_FH(__f_info) ((_FileHandle*)(__f_info)->fh)

static file_id_t get_id_number_from_file_name(char *name, char **new_start)
{
    /* Returns 0 if there isn't an ID that can be extracted from the file */
    char *p = strstr(name, FIS);
    file_id_t file_id = 0;
    *new_start = name;
    if (p)
    {
        /* Make sure it's really a number here */
        for (char *q = name; q < p; q++)
        {
            if (!isdigit(*q))
            {
                return 0;
            }
        }
        file_id = strtoul(name,NULL,10);
        *new_start = p + FIS_LENGTH; /* Put new start on the character after the colon */
    }
    return file_id;
}

Tag *path_to_tag (const char *path)
{
    Tag *res = NULL;
    if (g_strcmp0(path, "/") == 0)
    {
        return NULL;
    }

    char *base = fast_basename(path);
    res = lookup_tag(DB, base);

    if (res != NULL)
    {
        if ((base - 1) == path)
        {
            return res;
        }

        char **comps = split_path(path);
        gboolean proper_tag = TRUE;
        tagdb_key_t path_key = key_new();
        tagdb_key_t tags = tagdb_tag_tags(DB, res);
        for (int i = 0; comps[i+1] != NULL; i++)
        {
            Tag *t = lookup_tag(DB, comps[i]);
            if (!t)
            {
                g_strfreev(comps);
                key_destroy(path_key);
                key_destroy(tags);
                return NULL;
            }
            file_id_t tid = tag_id(t);

            if (proper_tag && !key_contains(tags, tid))
            {
                proper_tag = FALSE;
            }
            key_push_end(path_key, tid);
        }
        if (!proper_tag && !stage_lookup(STAGE, path_key, tag_id(res)))
        {
            res = NULL;
        }

        g_strfreev(comps);
        key_destroy(path_key);
        key_destroy(tags);
    }
    return res;
}

Tag *is_directory (const char *path)
{
    if (g_strcmp0(path, "/") == 0)
    {
        /* XXX: We are, of course assuming that there isn't any tag
         * at memory address 1. Generally a safe assumption, haha.
         */
        return (Tag*)TRUE;
    }
    return path_to_tag(path);
}

char *file_realpath (File *f)
{
    if (f)
        return tagfs_realpath_i(get_file_id((AbstractFile*)f));
    else
        return NULL;
}

// returns the file in our copies directory corresponding to
// the one in path
// should only be called on regular files since
// directories are only virtual
char *tagfs_realpath_i (file_id_t id)
{
    char *res = g_strdup_printf("%s/%ld", FSDATA->copiesdir, id);
    debug("realpath = \"%s\"", res);
    return res;
}

File *path_to_file (const char *path)
{
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *new_start;
    file_id_t idx = get_id_number_from_file_name(base, &new_start);

    File *f;
    if (idx != 0)
    {
        f = retrieve_file(DB, idx);
    }
    else
    {
        tagdb_key_t key = path_extract_key(dir);
        f = tagdb_lookup_file(DB, key, new_start);
        key_destroy(key);
    }

    g_free(base);
    g_free(dir);
    return f;
}

// turn the path into a file in the copies directory
// path_to_file_search_string + tagdb_query + file_realpath
// NULL for a file that DNE
char *get_file_copies_path (const char *path)
{
    File *f = path_to_file(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}

/* Translates the path into a NULL-terminated
 * vector of Tag IDs, the key format for our
 * FileTrie
 */
tagdb_key_t path_extract_key (const char *path)
{
    if (strcmp(path, "/") == 0)
    {
        return key_new();
    }
    /* Get the path components */
    char **comps = split_path(path);
    tagdb_key_t key = key_new();

    for (int i = 0; comps[i] != NULL; i++)
    {
        debug("path_extract_key:comps[i]=%s", comps[i]);
        Tag *t = lookup_tag(DB, comps[i]);
        if (t == NULL)
        {
            debug("path_extract_key:t == NULL");
            g_strfreev(comps);
            key_destroy(key);
            return NULL;
        }
        key_push_end(key, tag_id(t));
    }
    g_strfreev(comps);
    return key;
}

%(path_check path)
{
    return TRUE;
}

%(op utimens path timespecs)
{
    int retstat = -1;
    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        retstat = utimensat(0, fpath, timespecs, 0);
        g_free(fpath);
    }
    return retstat;
}

int file_stat (File *f, struct stat *statbuf)
{
    char *fpath = file_realpath(f);
    int stat = lstat(fpath, statbuf);
    statbuf->st_ino = file_id(f);
    g_free(fpath);
    return stat;
}

int tag_stat (Tag *t, struct stat *statbuf)
{
    statbuf->st_mode = DIR_PERMS;
    if (t != (Tag*)TRUE)
    {
        statbuf->st_ino = 0 - tag_id(t);
    }
    else
    {
        statbuf->st_ino = 0;
    }
    return 0;
}

%(op getattr path statbuf)
{
    int retstat = -ENOENT;

    tagdb_begin_transaction(DB);
    Tag *t = is_directory(path);
    if (t)
    {
        retstat = tag_stat(t, statbuf);
    }
    else
    {
        File *f = path_to_file(path);
        if (f)
        {
            int stat = file_stat(f, statbuf);
            if (stat == -1)
            {
                retstat = -errno;
            }
            else
            {
                retstat = 0;
            }

            debug("getattr:retstat = %d", retstat);
        }
    }
    tagdb_end_transaction(DB);
    return retstat;
}

int _move_directory(const char *path, const char *new_path);
int _move_file(const char *path, const char *newpath);
%(op rename path newpath)
{
    int retstat = 0;
    tagdb_begin_transaction(DB);
    if (is_directory(path))
    {
        retstat = _move_directory(path, newpath);
    }
    else
    {
        retstat = _move_file(path, newpath);
    }
    tagdb_end_transaction(DB);
    return retstat;
}

int _move_directory(const char *path, const char *newpath)
{
    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);
    char *newdir = g_path_get_dirname(newpath);
    int retstat = 0;

    if (strlen(newbase) >= MAX_FILE_NAME_LENGTH)
    {
        retstat = -ENAMETOOLONG;
    }
    else
    {
        Tag *t = lookup_tag(DB, oldbase);
        if (t)
        {
            if (is_directory(newpath))
            {
                retstat = -EEXIST;
            }
            else
            {
                if ((strlen(tag_name(t)) + strlen(newbase) - strlen(oldbase)) >= MAX_FILE_NAME_LENGTH)
                {
                    retstat = -ENAMETOOLONG;
                }
                else
                {
                    set_tag_name(DB, t, newbase);
                    tagdb_key_t key = path_extract_key(newdir);
                    assert(key != NULL);

                    if (!stage_add(STAGE, key, tag_id(t)))
                    {
                        error("Couldn't add stage entry for tag %s", tag_name(t));
                    }

                    key_destroy(key);
                }
            }
        }
        else
        {
            retstat = -ENOENT;
        }
    }

    g_free(oldbase);
    g_free(newbase);
    g_free(newdir);
    return retstat;
}

int _move_file(const char *path, const char *newpath)
{
    int retstat = 0;
    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);
    char *olddir = g_path_get_dirname(path);
    char *newdir = g_path_get_dirname(newpath);

    File *f = path_to_file(path);
    if (f)
    {
        char *old_start;
        char *new_start;
        file_id_t old_id = get_id_number_from_file_name(oldbase, &old_start); /* get the part of the file name after an ID */
        file_id_t new_id = get_id_number_from_file_name(newbase, &new_start);
        if ((old_id == new_id) || (old_id && !new_id))
        {
            /* Check if there is already a file with this name at this location
             *   Get the path key for newdir
             *   Lookup files by the path key and new_start
             *   Look for the one file that has exactly the tags in the path key
             *   If there's such a file, then delete it and so that this one can take its place
             *   Otherwise, do nothing further
             */
            debug("NEWDIR IS %s", newdir);
            tagdb_key_t new_tags = path_extract_key(newdir);
            if (new_tags) {
                if (strcmp(olddir, newdir) != 0)
                {
                    /* If there are any tags in the new path not in
                     * the old path, then we add tags. If the tags
                     * to add have no value attached to them, then
                     * we don't change the file for them.
                     *
                     * If the only tags in the new path are also
                     * present in the old path, then we remove tags
                     * that are present in the first, but not in
                     * the second.
                     *
                     * Note that this works because a file shouldn't
                     * appear in a location preceded by tags that it
                     * does not have. Since a user could access a file
                     * from anywhere if he has the ID, this assumption
                     * may be invalid. This case isn't really worth
                     * fixing though.
                     */
                    tagdb_key_t old_tags = path_extract_key(olddir);
                    GList *to_add = NULL;
                    KL(new_tags, i)
                    {
                        key_elem_t this_tag = key_ref(new_tags, i);
                        if (!key_contains(old_tags, this_tag))
                        {
                            to_add = g_list_prepend(to_add, TO_SP(this_tag));
                        }
                    } KL_END;

                    if (!to_add)
                    {
                        KL(old_tags, i)
                        {
                            file_id_t this_tag = (file_id_t)key_ref(old_tags, i);
                            if (!key_contains(new_tags, (key_elem_t)this_tag))
                            {
                                remove_tag_from_file(DB, f, this_tag);
                            }
                        } KL_END;
                    }
                    else
                    {
                        LL(to_add, it)
                        {
                            /* XXX: Be sure to add tag values here when
                             * we get to that
                             */
                            add_tag_to_file(DB, f, (file_id_t) TO_S(it->data), 0);
                        } LL_END;
                    }

                    g_list_free(to_add);
                    key_destroy(old_tags);
                }

                File *g = tagdb_lookup_file(DB, new_tags, new_start);
                if (g && (f != g) && file_only_has_tags(g, new_tags) && file_only_has_tags(f, new_tags))
                {
                    delete_file(DB, g);
                }

                key_destroy(new_tags);
                set_file_name(DB, f, new_start);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            retstat = -ENOENT;
        }
    }
    else
    {
        retstat = -ENOENT;
    }
    g_free(oldbase);
    g_free(newbase);
    g_free(olddir);
    g_free(newdir);
    return retstat;
}

%(op mknod path mode dev)
{

    int retstat = 0;

    char *base = g_path_get_basename(path);

    tagdb_begin_transaction(DB);
    File *f = tagdb_make_file(DB, base);
    tagdb_end_transaction(DB);
    char *fpath = file_realpath(f);
    /*
       if (S_ISREG(mode)) {
       retstat = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
       if (retstat >= 0)
       retstat = close(retstat);
       }
       else */
    if (S_ISFIFO(mode)) {
        retstat = mkfifo(fpath, mode);
    }
    else
    {
        retstat = mknod(fpath, mode, dev);
    }

    g_free(base);
    g_free(fpath);
    return retstat;
}

char *make_a_file_and_return_its_real_path(const char *path);
File *_make_file_from_path(const char *path);

%(op create path mode fi)
{
    int retstat = 0;
    char *realpath = NULL;
    tagdb_begin_transaction(DB);
    File *f = _make_file_from_path(path);
    tagdb_end_transaction(DB);
    if (f) {
        realpath = file_realpath(f);

        if (realpath == NULL)
        {
            log_msg("Invalid path in create\n");
            retstat = -ENOTDIR;
            goto END;
        }
        int fd = open(realpath, fi->flags, mode);

        if (fd >= 0)
        {
            fi->fh = TO_64(file_handle_new(fd, f));

            if (MCONN)
            {
                const char *name = file_name(f);
                uint32_t fid = file_id(f);
                _send_file_signal("file_created", fid, name);
                _send_file_signal("file_opened", fid, name);
            }
        }
        else
        {
            retstat = -1 * errno;
        }
    }

    END:
    g_free(realpath);
    return retstat;
}

%(op symlink path linkpath)
{
    int retstat = 0;
    char *realpath;
    tagdb_begin_transaction(DB);
    realpath = make_a_file_and_return_its_real_path(linkpath);
    tagdb_end_transaction(DB);
    if (realpath == NULL)
    {
        log_msg("Invalid path in symlink");
        retstat = -ENOTDIR;
    }
    else if (symlink(path, realpath) < 0)
    {
        retstat = -errno;
    }

    g_free(realpath);
    return retstat;
}

%(op readlink linkpath buf bufsize)
{
    int retstat = 0;
    ssize_t bytes_written = 0;
    char *realpath = get_file_copies_path(linkpath);
    if (realpath)
    {
        if ((bytes_written = readlink(realpath, buf, bufsize)) < 0)
        {
            retstat = -errno;
        }
        else
        {
            buf[bytes_written] = 0;
        }
    }
    g_free(realpath);
    return retstat;
}

File *_make_file_from_path(const char *path)
{
    File *f = NULL;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    /* The "copy index" can't legally start a name.
     * We just strip it so a user can't create it
     */
    char *new_start;
    (void)get_id_number_from_file_name(base, &new_start);
    tagdb_key_t tags = path_extract_key(dir);
    if (!tags)
    {
        goto BAD_PATH_END;
    }

    f = tagdb_make_file(DB, new_start);

    KL(tags, i)
    {
        add_tag_to_file(DB, f, key_ref(tags, i), NULL);
    } KL_END;

    // Has to happen before resource cleanup on a bad path since
    // key_destroy doesn't tolerate NULLs.
    key_destroy(tags);

    BAD_PATH_END:
    g_free(base);
    g_free(dir);

    return f;
}

char *make_a_file_and_return_its_real_path(const char *path)
{
    File *f = _make_file_from_path(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}


%(op mkdir path mode)
{
    %(log);
    int retstat = 0;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *p = NULL;
    if (strlen(base) >= MAX_FILE_NAME_LENGTH)
    {
        retstat = -ENAMETOOLONG;
        goto TAGDB_FS_MKDIR_END;
    }
    (void)get_id_number_from_file_name(base, &p);

    /* if there's any kind of id preceding the file, then we musn't accept it */
    if (base == p)
    {
        tagdb_begin_transaction(DB);
        Tag *t = lookup_tag(DB, base);
        if (t == NULL)
        {
            // Make a new tag object
            // give it int type with default value 0
            t = tagdb_make_tag(DB, base);
            if (t == NULL)
            {
                retstat = -ENOTDIR;
                tagdb_end_transaction(DB);
                goto TAGDB_FS_MKDIR_END;
            }
        }
        tagdb_key_t key = path_extract_key(dir);
        if (key)
        {
            if (!stage_add(STAGE, key, tag_id(t)))
            {
                retstat = -EEXIST;
            }
        }
        key_destroy(key);
        tagdb_end_transaction(DB);

        if (MCONN)
        {
            const char *name = tag_name(t);
            uint64_t tid = tag_id(t);
            _send_tag_signal("new_tag", tid, name);
        }
    }
    else
    {
        retstat = -ENOTDIR;
    }
    TAGDB_FS_MKDIR_END:
    g_free(base);
    g_free(dir);
    return retstat;
}

%(op rmdir path)
{
    int retstat = -1;
    char *base = g_path_get_basename(path);
    gboolean removed_alias = FALSE;
    file_id_t tag_id = 0;
    tagdb_begin_transaction(DB);

    tagdb_key_t path_key = path_extract_key(path);
    if (path_key) {
        tag_id = key_ref(path_key, key_length(path_key) - 1);
        key_destroy(path_key);

        Tag *t = retrieve_tag(DB, tag_id);

        if (tag_has_aliases(t))
        {
            if (tag_has_alias(t, base))
            {
                tagdb_tag_remove_alias(DB, t, base);
            }
            else
            {
                GSList *aliases = tag_aliases(t);
                char *tmp = g_strdup(aliases->data);
                tagdb_tag_remove_alias(DB, t, tmp);
                tagdb_set_tag_name(DB, t, tmp);
                g_free(tmp);
            }
            removed_alias = TRUE;
        }
        else
        {
            if (can_remove_tag(DB, t))
            {
                stage_remove_all(STAGE, tag_id);

                if (t)
                {
                    GList *files = tagdb_tag_files(DB, t);
                    LL (files, it)
                    {
                        File *f = it->data;
                        remove_tag_from_file(DB, f, tag_id);
                    } LL_END;

                    if (delete_tag(DB, t))
                    {
                        assert(lookup_tag(DB, base) == NULL);
                        assert(retrieve_tag(DB, tag_id) == NULL);
                        t = NULL;
                        retstat = 0;
                    }
                    g_list_free(files);
                }
            }
        }
    }
    else
    {
        retstat = -ENOENT;
    }

    tagdb_end_transaction(DB);

    if (MCONN)
    {
        if (retstat == 0)
        {
            if (removed_alias)
            {
                _send_tag_signal("removed_alias", tag_id, base);
            }
            else
            {
                _send_tag_signal("removed_tag", tag_id, base);
            }
        }
    }
    g_free(base);
    return retstat;
}

void _send_tag_signal (const char *signal, file_id_t tid, const char *name)
{
    int sig_id = _prepare_signal(signal, 10);
    if (sig_id >= 0)
    {
        CALL(MCONN, add_arg, sig_id, TAGDB_INT64_TYPE, &tid);
        CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &name);
        CALL(MCONN, send, sig_id);
        CALL(MCONN, destroy_message, sig_id);
    }
    else
    {
        warn("Couldn't send the '%s' signal", signal);
    }
}

%(op unlink path)
{
    int retstat = 0;
    uint32_t fid = 0;
    tagdb_begin_transaction(DB);
    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        if (fpath)
        {
            retstat = unlink(fpath);
            if (retstat >= 0)
            {
                fid = file_id(f);
                delete_file(DB, f);
                f = NULL;
            }
            g_free(fpath);
        }
    }
    tagdb_end_transaction(DB);

    if (MCONN)
    {
        if (fid != 0)
        {
            int sig_id = _prepare_signal("file_deleted", 10);
            if (sig_id >= 0)
            {
                CALL(MCONN, add_arg, sig_id, TAGDB_INT_TYPE, &fid);
                CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &path);
                CALL(MCONN, send, sig_id);
                CALL(MCONN, destroy_message, sig_id);
            }
            else
            {
                warn("Couldn't send the 'file_deleted' signal");
            }
        }
    }

    return retstat;
}

int _prepare_signal(const char *signal, const int max_tries) {
    int tries = 0;
    int sig_id = -1;
    do {
        sig_id = CALL(MCONN, prepare_signal, signal);
        tries++;
    } while (sig_id == -1 && tries < max_tries);
    return sig_id;
}

%(op open path f_info)
{
    int retstat = 0;
    int fd;

    // get the file id from the search path if necessary and get
    // the realpath from the id
    File *f = path_to_file(path);
    char *fpath = file_realpath(f);
    if (fpath)
    {
        fd = open(fpath, f_info->flags);
        g_free(fpath);

        f_info->fh = TO_64(file_handle_new(fd, f));
        if (MCONN)
        {
            uint32_t fid = file_id(f);
            _send_file_signal("file_opened", fid, path);
        }
    }
    else
    {
        retstat = -ENOENT;
    }
    return retstat;
}

void _send_file_signal(const char *signal, file_id_t fid, const char *path)
{
    int sig_id = _prepare_signal(signal, 10);

    if (sig_id >= 0)
    {
        CALL(MCONN, add_arg, sig_id, TAGDB_INT_TYPE, &fid);
        CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &path);
        CALL(MCONN, send, sig_id);
        CALL(MCONN, destroy_message, sig_id);
    }
    else
    {
        warn("Couldn't send the '%s' signal", signal);
    }
}

%(op release path f_info)
{
    int retstat = 0;
    _FileHandle *fh = TO_FH(f_info);
    if (!close(fh->fd))
    {
        if (MCONN)
        {
            File *f = fh->fp;
            if (f)
            {
                int sig_id = _prepare_signal("file_closed", 10);
                if (sig_id >= 0)
                {
                    uint32_t fid = file_id(f);

                    CALL(MCONN, add_arg, sig_id, TAGDB_INT_TYPE, &fid);
                    CALL(MCONN, send, sig_id);
                    CALL(MCONN, destroy_message, sig_id);
                }
                else
                {
                    warn("Couldn't send the 'file_closed' signal");
                }
            }
        }
    }
    else
    {
        retstat = -errno;
    }
    file_handle_destroy(fh);
    return retstat;
}

%(op write path buf size offset f_info)
{
    %(log)
    return pwrite(TO_FH(f_info)->fd, buf, size, offset);
}

%(op truncate path newsize)
{
    %(log)
    int retstat = 0;

    char *fpath = get_file_copies_path(path);

    if (fpath != NULL)
    {
        retstat = truncate(fpath, newsize);
        if (retstat < 0)
            retstat = log_error("tagfs_truncate truncate");
    }

    g_free(fpath);
    return retstat;
}

%(op ftruncate path size f_info)
{
    return ftruncate(TO_FH(f_info)->fd, size);
}

%(op read path buf size offset f_info)
{
    int r = pread(TO_FH(f_info)->fd, buf, size, offset);
    if (r == -1)
    {
        perror("tagdb_fs_read");
    }
    return r;
}

%(op fsync path datasync f_info)
{
    int retstat = 0;

    log_fi(f_info);
    int fd = TO_FH(f_info)->fd;
    if (datasync)
        retstat = fdatasync(fd);
    else
        retstat = fsync(fd);

    if (retstat < 0)
        log_error("tagdb_fs_fsync");
    return retstat;
}

%(op chmod path mode)
{
    char *file_realpath = get_file_copies_path(path);
    if (file_realpath)
    {
        int res = chmod(file_realpath, mode);
        g_free(file_realpath);
        if (res < 0)
        {
            res = -errno;
        }
        return res;
    }
    else
    {
        return -ENOENT;
    }
}

%(op chown path uid gid)
{
    char *file_realpath = get_file_copies_path(path);
    if (file_realpath)
    {
        int res = chown(file_realpath, uid, gid);
        g_free(file_realpath);
        if (res < 0)
        {
            res = -errno;
        }
        return res;
    }
    else
    {
        return -ENOENT;
    }
}

static int _readdir_list_file(fuse_fill_dir_t filler, void *buf, const char *name, const struct stat *statbuf)
{
    int res = 0;
    if (filler(buf, name, statbuf, 0))
    {
        error("tagdb_fs_readdir: filler: buffer full");
        res = 1;
    }
    return res;
}

#define list_file(__name, __filler, __buffer, __stat) \
if (_readdir_list_file((__filler), (__buffer), (const char*)(__name), (__stat)))\
{\
    res = -1;\
    goto READDIR_END;\
}

%(op readdir path buffer filler offset f_info)
{
    int res = 0;
    GList *f = NULL;
    GList *t = NULL;
    GHashTable* seen = NULL;
    GHashTable* seen_duplicates = NULL;
    GList *s = NULL;

    GList *combined_tags = NULL;
    char fname[MAX_FILE_NAME_LENGTH];
    struct stat statbuf;
    GList *prefixed_files = NULL;

    tagdb_key_t tags = path_extract_key(path);

    if (!tags)
    {
        return -1;
    }

    f = get_files_list(DB, tags);
    t = get_tags_list(DB, tags);

    GList *tmp = stage_list_position(STAGE, tags);
    LL(tmp, it)
    {
        s = g_list_prepend(s, retrieve_tag(DB, TO_S(it->data)));
    } LL_END
    g_list_free(tmp);

    seen = g_hash_table_new(g_str_hash, g_str_equal);
    LL(f, it)
    {
        if (it->data)
        {
            File *seen_file = g_hash_table_lookup(seen, file_name(it->data));
            if (seen_file && (seen_file != it->data))
            {
                prefixed_files = g_list_prepend(prefixed_files, it->data);
                /* maybe better to do this one once, but hey */
                prefixed_files = g_list_prepend(prefixed_files, seen_file);
            }
            else
            {
                (void)g_hash_table_insert(seen, (gpointer)file_name(it->data), it->data);
            }
        }
    } LL_END;

    {
        GList *seen_file_names = g_hash_table_get_keys(seen);
        LL(seen_file_names, it)
        {
            if (it->data)
            {
                File *f = g_hash_table_lookup(seen, it->data);
                if (f)
                {
                    if (file_stat(f, &statbuf) >= 0)
                    {
                        list_file(it->data, filler, buffer, &statbuf);
                    }
                    else
                    {
                        error("Couldn't stat file %s in readdir", it->data);
                    }
                }
                else
                {
                    error("Looked up NULL file in readdir `seen' table");
                }
            }
            else
            {
                error("Got NULL in readdir `seen_file_names'");
            }
        } LL_END;
        g_list_free(seen_file_names);
    }

    seen_duplicates = g_hash_table_new(g_direct_hash, g_direct_equal);
    LL(prefixed_files, it)
    {
        File *seen_file = g_hash_table_lookup(seen_duplicates, (gpointer)it->data);
        if (!seen_file)
        {
            file_to_string(it->data, fname);
            file_stat(it->data, &statbuf);
            list_file(fname, filler, buffer, &statbuf);
            (void)g_hash_table_insert(seen_duplicates, (gpointer)it->data, it->data);
        }
    } LL_END;
    g_hash_table_destroy(seen_duplicates);

    combined_tags = g_list_concat(t, s);
    LL(combined_tags, it)
    {
        Tag *t = (Tag*)it->data;
        tag_stat(t, &statbuf);
        tag_to_string1(t, fname, MAX_FILE_NAME_LENGTH);
        if (fname[0])
        {
            AbstractFile *f = g_hash_table_lookup(seen, fname);
            if (!f)
            {
                list_file(fname, filler, buffer, &statbuf);
                (void)g_hash_table_insert(seen, fname, t);
            }
            else
            {
                /* XXX: If the previously seen object is a File, then we will
                 * print out the prefixed name of the file. otherwise we just
                 * don't print out the name again
                 */
                if (file_is_file(f))
                {
                    file_to_string(f, fname);
                    list_file(fname, filler, buffer, NULL);
                }
            }
        }
        else
        {
            warn("readdir:Can't list overlong tag name");
        }

        SLL(t->aliases, ita)
        {
            AbstractFile *f = g_hash_table_lookup(seen, ita->data);
            if (!f)
            {
                list_file((char*)ita->data, filler, buffer, NULL);
                g_hash_table_insert(seen, ita->data, t);
            }
        } SLL_END;
    } LL_END;

    READDIR_END:
    g_hash_table_destroy(seen);
    key_destroy(tags);
    g_list_free(f);
    g_list_free(prefixed_files);
    g_list_free(combined_tags);
    return res;
}

%(op listxattr path list size)
{
    File *f = path_to_file(path);
    char fname[MAX_FILE_NAME_LENGTH];
    int res = -ENOENT;
    if (f)
    {
        GString *s = g_string_sized_new(24); /* XXX: What's a good value? No idea. */
        GList *tags = file_tag_ids(f);
        size_t real_size = 0;

        LL(tags, it)
        {
            file_id_t tag_id = TO_S(it->data);
            Tag *t = retrieve_tag(DB, tag_id);
            tag_to_string1(t, fname, MAX_FILE_NAME_LENGTH);
            if (fname[0])
            {
                real_size += strlen(fname);
                real_size += 1 + strlen(XATTR_PREFIX);
                (void)g_string_append_printf(s, XATTR_PREFIX"%s", fname);
                (void)g_string_append_c(s, 0);
            }
            else
            {
                warn("listxattr:Overlong tag name");
            }
        } LL_END;

        {
            char *realpath = file_realpath(f);
            char *l = "";
            ssize_t list_size = llistxattr(realpath, l, 0);
            if (list_size >= 0)
            {
                l = g_try_malloc(list_size);
                if (l)
                {
                    ssize_t real_list_size = llistxattr(realpath, l, list_size);
                    if (real_list_size > 0)
                    {
                        (void)g_string_append_len(s, l, real_list_size);
                    }
                    real_size += real_list_size;
                }
                else
                {
                    res = -ERANGE;
                }
                g_free(l);
            }
            g_free(realpath);
        }

        if (list && size > 0)
        {
            if (size < real_size)
            {
                res = -ERANGE;
            }
            else
            {
                memmove(list, s->str, real_size);
                res = (int)real_size;
            }
        }
        else
        {
            res = (int)real_size;
        }
        g_list_free(tags);
        g_string_free(s, FALSE);
    }
    return res;
}

%(op getxattr path name value size)
{
    if (value && size > 0)
    {
        value[0] = 0;
    }
    return 0;
}

%(op setxattr path name value size flags)
{
    /* XXX: `value' and `size' are not used */
    File *f = path_to_file(path);
    /*char value_buffer[size]; */
    int res = -ENOENT;
    Tag *t = NULL;
    if (f)
    {
        /* If there's a value, then we just ignore it. If the create flag is
         * given, then we add a tag if there isn't one and return error if there is one.
         * If the replace flag is given, then we return error if the tag isn't on the file
         * and return success if there is one.
         */
        if (strncmp(XATTR_PREFIX, name, strlen(XATTR_PREFIX)) == 0)
        {
            name = name + strlen(XATTR_PREFIX);
            if (strchr(name, '/'))
            {
                res = -EINVAL;
                goto END;
            }
            t = lookup_tag(DB, name);
            if (flags & XATTR_CREATE)
            {
                if (t)
                {
                    res = -EEXIST;
                    goto END;
                }
                else
                {
                    if (strlen(name) > 0)
                    {
                        t = tagdb_make_tag(DB, name);
                    }
                    else
                    {
                        res = -EINVAL;
                        goto END;
                    }
                }
            }
            else if ((flags & XATTR_REPLACE) && !t)
            {
                res = -ENOATTR;
                goto END;
            }
            else
            {
                if (strlen(name) > 0)
                {
                    t = tagdb_make_tag(DB, name);
                }
                else
                {
                    res = -EINVAL;
                    goto END;
                }
            }

            if (!(flags & XATTR_REPLACE))
            {

                add_tag_to_file(DB, f, tag_id(t), 0);
            }
            res = 0;
        }
        else
        {
            char *realpath = file_realpath(f);
            int stat = lsetxattr(realpath, name, value, size, flags);
            if (stat < 0)
            {
                res = -1 * errno;
            }
            else
            {
                res = 0;
            }
            g_free(realpath);
        }
    }
    END:
    return res;
}

%(op removexattr path name)
{
    File *f = path_to_file(path);
    int res = -ENOENT;
    Tag *t = NULL;
    if (f)
    {
        if (strncmp(XATTR_PREFIX, name, strlen(XATTR_PREFIX)) == 0)
        {
            name = name + strlen(XATTR_PREFIX);

            if (strlen(name) > 0)
            {
                t = lookup_tag(DB, name);
                if (t)
                {
                    remove_tag_from_file(DB, f, tag_id(t));
                }
                res = 0;
            }
            else
            {
                res = -EINVAL;
            }

        }
        else
        {
            char *realpath = file_realpath(f);
            int stat = lremovexattr(realpath, name);
            if (stat < 0)
            {
                res = -1 * errno;
            }
            else
            {
                res = 0;
            }
            g_free(realpath);
        }
    }
    return res;
}

_FileHandle *file_handle_new(int fd, File *fp)
{
    _FileHandle *fh = malloc(sizeof(_FileHandle));
    fh->fd = fd;
    fh->fp = fp;
    return fh;
}

void file_handle_destroy(_FileHandle* fh)
{
    free(fh);
}

%(subfs_component)
