#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <attr/xattr.h>
#include <assert.h>
#include "private/glib_future.h"
#include "params.h"
#include "util.h"
#include "tagdb.h"
#include "tagdb_fs.h"
#include "tagdb_util.h"
#include "path_util.h"
#include "fs_util.h"
#include "set_ops.h"
#include "file_log.h"
#include "fs_util.h"
#include "log.h"
#include "subfs.h"
#include "plugin_manager.h"
#include "asp.h"

typedef struct {
    int fd;
    File *fp;
} _FileHandle;

_FileHandle *file_handle_new(int fd, File *fp);
void file_handle_destroy(_FileHandle*);
int _prepare_signal(const char *signal, const int max_tries);
void _send_tag_signal (const char *signal, file_id_t tid, const char *name);
void _send_file_signal(const char *signal, file_id_t fid, const char *path);
GHashTable *get_plugin_tags_from_path(const char *path, GList *tag_list_populators, char ***res_comps);
PluginTag *lookup_plugin_tag(const char *path, const char *base);
/** Determines if all of the tags in the table are non-empty according to their respective plugins
 */
gboolean all_path_plugin_tags_are_legitimate (GHashTable *plugin_tags_table, GList *files);
tagdb_key_t path_extract_key0 (char **comps);
void plugins_tag_list_destroy(gpointer gp);

/** Destructively filters the given files by the given table of plugin tags
 * The table should be as returned from get_plugin_tags_from_path:
 *     plugin names -> GList of plugin tags
 */
GList *filter_files_by_plugin_tags(GHashTable *plugin_tags_table, GList *files);

#define TO_FH(__f_info) ((_FileHandle*)(__f_info)->fh)

static file_id_t get_id_number_from_file_name(char *name, char **new_start)
{
    /* Returns 0 if there isn't an ID that can be extracted from the file */
    char *p = strstr(name, FIS);
    file_id_t file_id = 0;
    *new_start = name;
    if (p)
    {
        /* Make sure it's really a number here */
        for (char *q = name; q < p; q++)
        {
            if (!isdigit(*q))
            {
                return 0;
            }
        }
        file_id = strtoul(name,NULL,10);
        *new_start = p + FIS_LENGTH; /* Put new start on the character after the colon */
    }
    return file_id;
}

Tag *path_to_tag (const char *path)
{
    Tag *res = NULL;
    if (g_strcmp0(path, "/") == 0)
    {
        return NULL;
    }

    char *base = fast_basename(path);
    res = lookup_tag(DB, base);

    if (res)
    {
        if (base - 1 == path)
        {
            return res;
        }

        char **comps = NULL;
        tagdb_key_t tags = tagdb_tag_tags(DB, res);

        GList *plugins = plugin_manager_get_plugins(PM, "TagListPopulator");
        char *dir = g_path_get_dirname(path);

        GHashTable *plugin_tags_table = get_plugin_tags_from_path(dir, plugins, &comps);
        tagdb_key_t path_key = path_extract_key0(comps);

        if (key_contains(path_key, tag_id(res)))
        {
            debug("The basename tag '%s' appears in the path '%s' (possibly as an alias)", base, dir);
            res = NULL;
        }
        else
        {
            gboolean staged = FALSE;
            KL (path_key, i)
            {
                if (!key_contains(tags, key_ref(path_key, i)))
                {
                    if (!stage_lookup(STAGE, path_key, tag_id(res)))
                    {
                        res = NULL;
                    }
                    else
                    {
                        staged = TRUE;
                    }
                    break;
                }
            } KL_END

            if (res && !staged && plugin_tags_table && g_hash_table_size(plugin_tags_table) > 0)
            {
                GList *files = get_files_list(DB, path_key);
                if (!all_path_plugin_tags_are_legitimate(plugin_tags_table, files))
                {
                    res = NULL;
                }
                g_list_free(files);
            }
        }
        if (plugin_tags_table)
        {
            g_hash_table_destroy(plugin_tags_table);
        }
        g_strfreev(comps);
        g_free(dir);
        key_destroy(path_key);
        key_destroy(tags);
    }
    else
    {
        debug("%s is maybe a plugin tag?", path);
        res = (Tag*)lookup_plugin_tag(path, base);
    }
    return res;
}

gboolean all_path_plugin_tags_are_legitimate (GHashTable *ptt, GList *files)
{
    gboolean res = TRUE;
    if (files)
    {
        HL (ptt, _, k, v)
        {
            TagListPopulator *tlp = plugin_manager_get_plugin(PM, TagListPopulator, k);
            if (tlp)
            {
                GList *populate_tags = PMCALL(tlp, populate, files);
                GList *path_tags_for_plugin = (GList*) v;
                gboolean path_plugin_tags_are_good = TRUE;

                LL (path_tags_for_plugin, it)
                {
                    gboolean match = FALSE;
                    LL (populate_tags, itt)
                    {
                        const char *populate_tag_name = tag_name(itt->data);
                        const char *path_tag_name = tag_name(it->data);
                        debug("all_path_plugin_tags_are_legitimate:comparing %s and %s", path_tag_name, path_tag_name);
                        if (g_strcmp0(populate_tag_name, path_tag_name) == 0)
                        {
                            match = TRUE;
                            break;
                        }
                    } LL_END

                    if (!match)
                    {
                        path_plugin_tags_are_good = FALSE;
                        break;
                    }
                } LL_END

                if (!path_plugin_tags_are_good)
                {
                    res = FALSE;
                }
                plugins_tag_list_destroy(populate_tags);
            }
            else
            {
                res = FALSE;
                // TODO: Not sure how graceful this failure is. Need to check
                warn("The plugin, '%s', is no longer registered", (char*)k);
            }
        } HL_END
    }
    else
    {
        res = FALSE;
        debug("No files could exist for the parent path => no tag");
    }

    return res;
}

PluginTag *lookup_plugin_tag(const char *path, const char *base)
{
    GList *plugins = plugin_manager_get_plugins(PM, "TagListPopulator");
    PluginTag *pt = NULL;
    LL (plugins, it)
    {
        TagListPopulator *the_plugin = (TagListPopulator*) it->data;
        if ((pt = PMCALL(the_plugin, get_tag, base)))
        {
            break;
        }
    } LL_END

    if (pt)
    {
        char **comps = NULL;
        GHashTable *plugin_tags_table = get_plugin_tags_from_path(path, plugins, &comps);
        tagdb_key_t tags = path_extract_key0(comps);

        if (!tags)
        {
            plugin_tag_destroy(pt);
            pt = NULL;
        }
        else
        {
            GList *f = get_files_list(DB, tags);
            GList *filtered = filter_files_by_plugin_tags(plugin_tags_table, f);
            /* unchanged should really only be true if tag disappeared between getting
             * `res` and getting `plugin_tags_table` or if the plugin for the tag was
             * unregistered
             */
            gboolean unchanged = filtered == f;

            if (!filtered || unchanged)
            {
                plugin_tag_destroy(pt);
                pt = NULL;
            }
            else
            {
                GList *plugin_tags = g_hash_table_lookup(plugin_tags_table, plugin_tag_plugin_name(pt));
                int nmatch = 0;
                LL (plugin_tags, it)
                {
                    if (g_strcmp0(tag_name(it->data), tag_name(pt)) == 0
                            || tag_id(it->data) == tag_id(pt))
                    {
                        nmatch++;
                    }
                } LL_END

                if (nmatch > 1)
                {
                    plugin_tag_destroy(pt);
                    pt = NULL;
                }
            }

            g_list_free(filtered);
        }
        key_destroy(tags);
        g_strfreev(comps);
        g_hash_table_destroy(plugin_tags_table);
    }
    return pt;
}

Tag *is_directory (const char *path)
{
    if (g_strcmp0(path, "/") == 0)
    {
        /* XXX: We are, of course assuming that there isn't any tag
         * at memory address 1. Generally a safe assumption, haha.
         */
        return FSDATA->root_tag;
    }
    return path_to_tag(path);
}

char *file_realpath (File *f)
{
    if (f)
        return tagfs_realpath_i(get_file_id((AbstractFile*)f));
    else
        return NULL;
}

// returns the file in our copies directory corresponding to
// the one in path
// should only be called on regular files since
// directories are only virtual
char *tagfs_realpath_i (file_id_t id)
{
    char *res = g_strdup_printf("%s/%" TAGFS_FILE_ID_PRINTF_FORMAT, FSDATA->copiesdir, id);
    debug("realpath = \"%s\"", res);
    return res;
}

File *path_to_file (const char *path)
{
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *new_start;
    file_id_t idx = get_id_number_from_file_name(base, &new_start);

    File *f = NULL;
    if (idx != 0)
    {
        f = retrieve_file(DB, idx);
    }
    else
    {
        tagdb_key_t key = path_extract_key(dir);
        if (!key)
        {
            char **comps = NULL;
            GList *plugins = plugin_manager_get_plugins(PM, "TagListPopulator");
            GHashTable *plugin_tags_table = get_plugin_tags_from_path(dir,
                    plugins, &comps);
            tagdb_key_t tags = path_extract_key0(comps);
            if (tags)
            {
                f = tagdb_lookup_file(DB, tags, new_start);
                if (f)
                {
                    GList *l = g_list_append(NULL, f);
                    GList *filtered = filter_files_by_plugin_tags(plugin_tags_table, l);
                    if (!filtered)
                    {
                        debug("Filtered out the files");
                        f = NULL;
                    }
                    g_list_free(filtered);
                }
                else
                {
                    debug("Couldn't find the files even after removing plugin tags");
                }
                key_destroy(tags);
            }
            g_strfreev(comps);
            g_hash_table_destroy(plugin_tags_table);
        }
        else
        {
            f = tagdb_lookup_file(DB, key, new_start);
            key_destroy(key);
        }
    }

    g_free(base);
    g_free(dir);
    return f;
}

// turn the path into a file in the copies directory
// path_to_file_search_string + tagdb_query + file_realpath
// NULL for a file that DNE
char *get_file_copies_path (const char *path)
{
    File *f = path_to_file(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}

/* Translates the path into a NULL-terminated
 * vector of Tag IDs, the key format for our
 * FileTrie
 */
tagdb_key_t path_extract_key (const char *path)
{
    if (strcmp(path, "/") == 0)
    {
        return key_new();
    }
    /* Get the path components */
    char **comps = split_path(path);
    tagdb_key_t key = path_extract_key0(comps);
    g_strfreev(comps);
    return key;
}

tagdb_key_t path_extract_key0 (char **comps)
{
    tagdb_key_t key = key_new();
    for (int i = 0; comps[i] != NULL; i++)
    {
        debug("path_extract_key:comps[i]=%s", comps[i]);
        Tag *t = lookup_tag(DB, comps[i]);
        if (t == NULL)
        {
            debug("path_extract_key:t == NULL");
            key_destroy(key);
            return NULL;
        }
        key_push_end(key, tag_id(t));
    }
    return key;
}

%(path_check path)
{
    return TRUE;
}

%(op utimens path timespecs)
{
    int retstat = -1;
    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        retstat = utimensat(0, fpath, timespecs, 0);
        g_free(fpath);
    }
    return retstat;
}

int file_stat (File *f, struct stat *statbuf)
{
    char *fpath = file_realpath(f);
    int stat = lstat(fpath, statbuf);
    statbuf->st_ino = file_id(f);
    g_free(fpath);
    return stat;
}

int tag_stat (Tag *t, struct stat *statbuf)
{
    statbuf->st_mode = DIR_PERMS;
    statbuf->st_ino = 0 - tag_id(t);
    return 0;
}

%(op getattr path statbuf)
{
    int retstat = -ENOENT;

    tagdb_begin_transaction(DB);
    Tag *t = is_directory(path);
    if (t)
    {
        debug("%s is a directory", path);
        retstat = tag_stat(t, statbuf);
        if (tag_is_plugin_tag(t))
        {
            plugin_tag_destroy((PluginTag*)t);
        }
    }
    else
    {
        File *f = path_to_file(path);
        if (f)
        {
            debug("%s is a file", path);
            int stat = file_stat(f, statbuf);
            if (stat == -1)
            {
                retstat = -errno;
            }
            else
            {
                retstat = 0;
            }
        }
        else
        {
        }
    }
    tagdb_end_transaction(DB);
    debug("getattr:retstat = %d", retstat);
    return retstat;
}

int _move_directory(const char *path, const char *new_path);
int _move_file(const char *path, const char *newpath);
%(op rename path newpath)
{
    int retstat = 0;
    tagdb_begin_transaction(DB);
    if (is_directory(path))
    {
        retstat = _move_directory(path, newpath);
    }
    else
    {
        retstat = _move_file(path, newpath);
    }
    tagdb_end_transaction(DB);
    return retstat;
}

int _move_directory(const char *path, const char *newpath)
{
    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);
    char *newdir = g_path_get_dirname(newpath);
    int retstat = 0;

    if (strlen(newbase) >= MAX_FILE_NAME_LENGTH)
    {
        retstat = -ENAMETOOLONG;
    }
    else
    {
        Tag *t = lookup_tag(DB, oldbase);
        if (t)
        {
            if (is_directory(newpath))
            {
                retstat = -EEXIST;
            }
            else
            {
                if ((strlen(tag_name(t)) + strlen(newbase) - strlen(oldbase)) >= MAX_FILE_NAME_LENGTH)
                {
                    retstat = -ENAMETOOLONG;
                }
                else
                {
                    set_tag_name(DB, t, newbase);
                    tagdb_key_t key = path_extract_key(newdir);
                    assert(key != NULL);

                    if (!stage_add(STAGE, key, tag_id(t)))
                    {
                        error("Couldn't add stage entry for tag %s", tag_name(t));
                    }

                    key_destroy(key);
                }
            }
        }
        else
        {
            retstat = -ENOENT;
        }
    }

    g_free(oldbase);
    g_free(newbase);
    g_free(newdir);
    return retstat;
}

int _move_file(const char *path, const char *newpath)
{
    int retstat = 0;
    char *oldbase = g_path_get_basename(path);
    char *newbase = g_path_get_basename(newpath);
    char *olddir = g_path_get_dirname(path);
    char *newdir = g_path_get_dirname(newpath);

    File *f = path_to_file(path);
    if (f)
    {
        char *old_start;
        char *new_start;
        file_id_t old_id = get_id_number_from_file_name(oldbase, &old_start); /* get the part of the file name after an ID */
        file_id_t new_id = get_id_number_from_file_name(newbase, &new_start);
        if ((old_id == new_id) || (old_id && !new_id))
        {
            /* Check if there is already a file with this name at this location
             *   Get the path key for newdir
             *   Lookup files by the path key and new_start
             *   Look for the one file that has exactly the tags in the path key
             *   If there's such a file, then delete it and so that this one can take its place
             *   Otherwise, do nothing further
             */
            debug("NEWDIR IS %s", newdir);
            tagdb_key_t new_tags = path_extract_key(newdir);
            if (new_tags) {
                if (strcmp(olddir, newdir) != 0)
                {
                    /* If there are any tags in the new path not in
                     * the old path, then we add tags. If the tags
                     * to add have no value attached to them, then
                     * we don't change the file for them.
                     *
                     * If the only tags in the new path are also
                     * present in the old path, then we remove tags
                     * that are present in the first, but not in
                     * the second.
                     *
                     * Note that this works because a file shouldn't
                     * appear in a location preceded by tags that it
                     * does not have. Since a user could access a file
                     * from anywhere if he has the ID, this assumption
                     * may be invalid. This case isn't really worth
                     * fixing though.
                     */
                    tagdb_key_t old_tags = path_extract_key(olddir);
                    GList *to_add = NULL;
                    KL(new_tags, i)
                    {
                        key_elem_t this_tag = key_ref(new_tags, i);
                        if (!key_contains(old_tags, this_tag))
                        {
                            to_add = g_list_prepend(to_add, TO_SP(this_tag));
                        }
                    } KL_END;

                    if (!to_add)
                    {
                        KL(old_tags, i)
                        {
                            file_id_t this_tag = (file_id_t)key_ref(old_tags, i);
                            if (!key_contains(new_tags, (key_elem_t)this_tag))
                            {
                                remove_tag_from_file(DB, f, this_tag);
                            }
                        } KL_END;
                    }
                    else
                    {
                        LL(to_add, it)
                        {
                            /* XXX: Be sure to add tag values here when
                             * we get to that
                             */
                            add_tag_to_file(DB, f, (file_id_t) TO_S(it->data), 0);
                        } LL_END;
                    }

                    g_list_free(to_add);
                    key_destroy(old_tags);
                }

                File *g = tagdb_lookup_file(DB, new_tags, new_start);
                if (g && (f != g) && file_only_has_tags(g, new_tags) && file_only_has_tags(f, new_tags))
                {
                    delete_file(DB, g);
                }

                key_destroy(new_tags);
                set_file_name(DB, f, new_start);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            retstat = -ENOENT;
        }
    }
    else
    {
        retstat = -ENOENT;
    }
    g_free(oldbase);
    g_free(newbase);
    g_free(olddir);
    g_free(newdir);
    return retstat;
}

%(op mknod path mode dev)
{
    int retstat = 0;

    char *base = g_path_get_basename(path);

    tagdb_begin_transaction(DB);
    File *f = tagdb_make_file(DB, base);
    tagdb_end_transaction(DB);
    char *fpath = file_realpath(f);
    /*
       if (S_ISREG(mode)) {
       retstat = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
       if (retstat >= 0)
       retstat = close(retstat);
       }
       else */
    if (S_ISFIFO(mode)) {
        retstat = mkfifo(fpath, mode);
    }
    else
    {
        retstat = mknod(fpath, mode, dev);
    }

    g_free(base);
    g_free(fpath);
    return retstat;
}

char *make_a_file_and_return_its_real_path(const char *path);
File *_make_file_from_path(const char *path);

%(op create path mode fi)
{
    int retstat = 0;
    char *realpath = NULL;
    tagdb_begin_transaction(DB);
    File *f = _make_file_from_path(path);

    tagdb_end_transaction(DB);
    if (f) {
        realpath = file_realpath(f);

        if (realpath == NULL)
        {
            log_msg("Invalid path in create\n");
            retstat = -ENOTDIR;
            goto END;
        }
        int fd = open(realpath, fi->flags, mode);

        if (fd >= 0)
        {
            fi->fh = TO_64(file_handle_new(fd, f));

            if (MCONN)
            {
                const char *name = file_name(f);
                uint32_t fid = file_id(f);
                _send_file_signal("file_created", fid, name);
                _send_file_signal("file_opened", fid, name);
            }
        }
        else
        {
            retstat = -1 * errno;
        }
    }

    END:
    g_free(realpath);
    return retstat;
}

%(op symlink path linkpath)
{
    int retstat = 0;
    char *realpath;
    tagdb_begin_transaction(DB);
    realpath = make_a_file_and_return_its_real_path(linkpath);
    tagdb_end_transaction(DB);
    if (realpath == NULL)
    {
        log_msg("Invalid path in symlink");
        retstat = -ENOTDIR;
    }
    else if (symlink(path, realpath) < 0)
    {
        retstat = -errno;
    }

    g_free(realpath);
    return retstat;
}

%(op readlink linkpath buf bufsize)
{
    int retstat = 0;
    ssize_t bytes_written = 0;
    char *realpath = get_file_copies_path(linkpath);
    if (realpath)
    {
        if ((bytes_written = readlink(realpath, buf, bufsize)) < 0)
        {
            retstat = -errno;
        }
        else
        {
            buf[bytes_written] = 0;
        }
    }
    g_free(realpath);
    return retstat;
}

File *_make_file_from_path(const char *path)
{
    File *f = NULL;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    if (base[0] == '/' || (base[0] == '.' && base[1] == 0))
    {
        goto BAD_PATH_END;
    }
    /* The "copy index" can't legally start a name.
     * We just strip it so a user can't create it
     */
    char *new_start;
    (void)get_id_number_from_file_name(base, &new_start);
    tagdb_key_t tags = path_extract_key(dir);
    if (!tags)
    {
        goto BAD_PATH_END;
    }

    f = tagdb_make_file(DB, new_start);

    KL(tags, i)
    {
        add_tag_to_file(DB, f, key_ref(tags, i), NULL);
    } KL_END;

    // Has to happen before resource cleanup on a bad path since
    // key_destroy doesn't tolerate NULLs.
    key_destroy(tags);

    BAD_PATH_END:
    g_free(base);
    g_free(dir);

    return f;
}

char *make_a_file_and_return_its_real_path(const char *path)
{
    File *f = _make_file_from_path(path);
    if (f)
        return file_realpath(f);
    else
        return NULL;
}


%(op mkdir path mode)
{
    %(log);
    int retstat = 0;
    char *base = g_path_get_basename(path);
    char *dir = g_path_get_dirname(path);
    char *p = NULL;
    if (strlen(base) >= MAX_FILE_NAME_LENGTH)
    {
        retstat = -ENAMETOOLONG;
        goto TAGDB_FS_MKDIR_END;
    }
    (void)get_id_number_from_file_name(base, &p);

    /* if there's any kind of id preceding the file, then we must not accept it */
    if (base == p)
    {
        tagdb_begin_transaction(DB);
        Tag *t = lookup_tag(DB, base);
        if (t == NULL)
        {
            // Make a new tag object
            // give it int type with default value 0
            t = tagdb_make_tag(DB, base);
            if (t == NULL)
            {
                retstat = -ENOTDIR;
                tagdb_end_transaction(DB);
                goto TAGDB_FS_MKDIR_END;
            }
        }
        tagdb_key_t key = path_extract_key(dir);
        if (key)
        {
            if (!stage_add(STAGE, key, tag_id(t)))
            {
                retstat = -EEXIST;
            }
        }
        key_destroy(key);
        tagdb_end_transaction(DB);

        if (MCONN)
        {
            const char *name = tag_name(t);
            uint64_t tid = tag_id(t);
            _send_tag_signal("new_tag", tid, name);
        }
    }
    else
    {
        retstat = -ENOTDIR;
    }
    TAGDB_FS_MKDIR_END:
    g_free(base);
    g_free(dir);
    return retstat;
}

%(op rmdir path)
{
    int retstat = -1;
    char *base = g_path_get_basename(path);
    gboolean removed_alias = FALSE;
    file_id_t tag_id = 0;
    tagdb_begin_transaction(DB);

    tagdb_key_t path_key = path_extract_key(path);
    if (path_key) {
        tag_id = key_ref(path_key, key_length(path_key) - 1);
        key_destroy(path_key);

        Tag *t = retrieve_tag(DB, tag_id);

        if (tag_has_aliases(t))
        {
            if (tag_has_alias(t, base))
            {
                tagdb_tag_remove_alias(DB, t, base);
            }
            else
            {
                GSList *aliases = tag_aliases(t);
                char *tmp = g_strdup(aliases->data);
                tagdb_tag_remove_alias(DB, t, tmp);
                tagdb_set_tag_name(DB, t, tmp);
                g_free(tmp);
            }
            removed_alias = TRUE;
        }
        else
        {
            if (can_remove_tag(DB, t))
            {
                stage_remove_all(STAGE, tag_id);

                if (t)
                {
                    GList *files = tagdb_tag_files(DB, t);
                    LL (files, it)
                    {
                        File *f = it->data;
                        remove_tag_from_file(DB, f, tag_id);
                    } LL_END;

                    if (delete_tag(DB, t))
                    {
                        assert(lookup_tag(DB, base) == NULL);
                        assert(retrieve_tag(DB, tag_id) == NULL);
                        t = NULL;
                        retstat = 0;
                    }
                    g_list_free(files);
                }
            }
        }
    }
    else
    {
        retstat = -ENOENT;
    }

    tagdb_end_transaction(DB);

    if (MCONN)
    {
        if (retstat == 0)
        {
            if (removed_alias)
            {
                _send_tag_signal("removed_alias", tag_id, base);
            }
            else
            {
                _send_tag_signal("removed_tag", tag_id, base);
            }
        }
    }
    g_free(base);
    return retstat;
}

void _send_tag_signal (const char *signal, file_id_t tid, const char *name)
{
    int sig_id = _prepare_signal(signal, 10);
    if (sig_id >= 0)
    {
        CALL(MCONN, add_arg, sig_id, TAGDB_INT64_TYPE, &tid);
        CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &name);
        CALL(MCONN, send, sig_id);
        CALL(MCONN, destroy_message, sig_id);
    }
    else
    {
        warn("Couldn't send the '%s' signal", signal);
    }
}

%(op unlink path)
{
    int retstat = 0;
    uint32_t fid = 0;
    tagdb_begin_transaction(DB);
    File *f = path_to_file(path);
    if (f)
    {
        char *fpath = file_realpath(f);
        if (fpath)
        {
            retstat = unlink(fpath);
            if (retstat >= 0)
            {
                fid = file_id(f);
                delete_file(DB, f);
                f = NULL;
            }
            g_free(fpath);
        }
    }
    tagdb_end_transaction(DB);

    if (MCONN)
    {
        if (fid != 0)
        {
            int sig_id = _prepare_signal("file_deleted", 10);
            if (sig_id >= 0)
            {
                CALL(MCONN, add_arg, sig_id, TAGFS_FILE_ID_TAGDB_TYPE, &fid);
                CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &path);
                CALL(MCONN, send, sig_id);
                CALL(MCONN, destroy_message, sig_id);
            }
            else
            {
                warn("Couldn't send the 'file_deleted' signal");
            }
        }
    }

    return retstat;
}

int _prepare_signal(const char *signal, const int max_tries) {
    int tries = 0;
    int sig_id = -1;
    do {
        sig_id = CALL(MCONN, prepare_signal, signal);
        tries++;
    } while (sig_id == -1 && tries < max_tries);
    return sig_id;
}

%(op open path f_info)
{
    int retstat = 0;
    int fd;

    // get the file id from the search path if necessary and get
    // the realpath from the id
    File *f = path_to_file(path);
    char *fpath = file_realpath(f);
    if (fpath)
    {
        fd = open(fpath, f_info->flags);
        g_free(fpath);

        f_info->fh = TO_64(file_handle_new(fd, f));
        if (MCONN)
        {
            uint32_t fid = file_id(f);
            _send_file_signal("file_opened", fid, path);
        }
    }
    else
    {
        retstat = -ENOENT;
    }
    return retstat;
}

void _send_file_signal(const char *signal, file_id_t fid, const char *path)
{
    int sig_id = _prepare_signal(signal, 10);

    if (sig_id >= 0)
    {
        CALL(MCONN, add_arg, sig_id, TAGDB_INT_TYPE, &fid);
        CALL(MCONN, add_arg, sig_id, TAGDB_STR_TYPE, &path);
        CALL(MCONN, send, sig_id);
        CALL(MCONN, destroy_message, sig_id);
    }
    else
    {
        warn("Couldn't send the '%s' signal", signal);
    }
}

%(op release path f_info)
{
    int retstat = 0;
    _FileHandle *fh = TO_FH(f_info);
    if (!close(fh->fd))
    {
        if (MCONN)
        {
            File *f = fh->fp;
            if (f)
            {
                int sig_id = _prepare_signal("file_closed", 10);
                if (sig_id >= 0)
                {
                    uint32_t fid = file_id(f);

                    CALL(MCONN, add_arg, sig_id, TAGDB_INT_TYPE, &fid);
                    CALL(MCONN, send, sig_id);
                    CALL(MCONN, destroy_message, sig_id);
                }
                else
                {
                    warn("Couldn't send the 'file_closed' signal");
                }
            }
        }
    }
    else
    {
        retstat = -errno;
    }
    file_handle_destroy(fh);
    return retstat;
}

%(op write path buf size offset f_info)
{
    %(log)
    return pwrite(TO_FH(f_info)->fd, buf, size, offset);
}

%(op truncate path newsize)
{
    %(log)
    int retstat = 0;

    char *fpath = get_file_copies_path(path);

    if (fpath != NULL)
    {
        retstat = truncate(fpath, newsize);
        if (retstat < 0)
            retstat = log_error("tagfs_truncate truncate");
    }

    g_free(fpath);
    return retstat;
}

%(op ftruncate path size f_info)
{
    return ftruncate(TO_FH(f_info)->fd, size);
}

%(op read path buf size offset f_info)
{
    int r = pread(TO_FH(f_info)->fd, buf, size, offset);
    if (r == -1)
    {
        perror("tagdb_fs_read");
    }
    return r;
}

%(op fsync path datasync f_info)
{
    int retstat = 0;

    log_fi(f_info);
    int fd = TO_FH(f_info)->fd;
    if (datasync)
        retstat = fdatasync(fd);
    else
        retstat = fsync(fd);

    if (retstat < 0)
        log_error("tagdb_fs_fsync");
    return retstat;
}

%(op chmod path mode)
{
    char *file_realpath = get_file_copies_path(path);
    if (file_realpath)
    {
        int res = chmod(file_realpath, mode);
        g_free(file_realpath);
        if (res < 0)
        {
            res = -errno;
        }
        return res;
    }
    else
    {
        return -ENOENT;
    }
}

%(op chown path uid gid)
{
    char *file_realpath = get_file_copies_path(path);
    if (file_realpath)
    {
        int res = chown(file_realpath, uid, gid);
        g_free(file_realpath);
        if (res < 0)
        {
            res = -errno;
        }
        return res;
    }
    else
    {
        return -ENOENT;
    }
}

static int _readdir_list_file(fuse_fill_dir_t filler, void *buf, const char *name, const struct stat *statbuf)
{
    int res = 0;
    if (filler(buf, name, statbuf, 0))
    {
        error("tagdb_fs_readdir: filler: buffer full");
        res = 1;
    }
    return res;
}

#define list_file(__name, __filler, __buffer, __stat) \
if (_readdir_list_file((__filler), (__buffer), (const char*)(__name), (__stat)))\
{\
    res = -1;\
    goto READDIR_END;\
}

void temp_tags_destroy (gpointer gp)
{
    Tag *t = (Tag*) gp;
    if (tag_is_plugin_tag(t)) {
        plugin_tag_destroy((PluginTag*)t);
    }
}

void plugins_tag_list_destroy(gpointer gp)
{
    GList *l = gp;
    g_list_free_full(l, (GDestroyNotify) plugin_tag_destroy);
}

GHashTable *get_plugin_tags_from_path(const char *path, GList *tag_list_populators, char ***res_comps)
{
    if (!tag_list_populators)
    {
        *res_comps = split_path(path);
        return NULL;
    }
    GHashTable *plugin_tags_table = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, plugins_tag_list_destroy);
    char **comps = split_path(path);
    guint len = g_strv_length(comps);
    if (res_comps != NULL)
    {
        *res_comps = g_malloc0(sizeof(char*) * (len + 1));
    }

    int i = 0;
    int j = 0;
    while (comps[i] != NULL)
    {
        int inc = 1;
        LL (tag_list_populators, it)
        {
            TagListPopulator *tlp = it->data;
            PluginTag *pt = NULL;
            if ((pt = PMCALL(tlp, get_tag, comps[i])))
            {
                if (lookup_tag(DB, comps[i]) == NULL)
                {
                    GList *plugin_tags = g_hash_table_lookup(plugin_tags_table, plugin_name(tlp));
                    g_hash_table_steal(plugin_tags_table, plugin_name(tlp));
                    plugin_tags = g_list_append(plugin_tags, pt);
                    g_hash_table_insert(plugin_tags_table, plugin_name(tlp), plugin_tags);
                    inc = 0;
                    break;
                }
                else
                {
                    info("Tag from plugin %s is hidden by manually created tag %s",
                            plugin_name(tlp), comps[i]);
                    plugin_tag_destroy(pt);
                }
            }
        } LL_END
        if (res_comps)
        {
            if ((*res_comps)[j])
            {
                g_free((*res_comps)[j]);
            }
            (*res_comps)[j] = g_strdup(comps[i]);
        }
        j += inc;
        i++;
    }

    if (res_comps)
    {
        i = 0;
        while ((*res_comps)[i] != NULL)
        {
            debug("res_comps[%d] = %s", i, (*res_comps)[i]);
            i++;
        }
        if ((*res_comps)[j])
        {
            g_free((*res_comps)[j]);
        }
        (*res_comps)[j] = NULL;
    }
    g_strfreev(comps);
    return plugin_tags_table;
}

%(op readdir path buffer filler offset f_info)
{
    int res = 0;
    GList *f = NULL;
    GList *t = NULL;
    GHashTable* seen = NULL;
    GHashTable* seen_duplicates = NULL;
    GList *s = NULL;

    GList *combined_tags = NULL;
    char fname[MAX_FILE_NAME_LENGTH];
    struct stat statbuf;
    GList *prefixed_files = NULL;
    char **comps = NULL;

    GList *tag_list_populators = plugin_manager_get_plugins(PM, "TagListPopulator");
    GHashTable *plugin_tags_table = get_plugin_tags_from_path(path, tag_list_populators, &comps);
    tagdb_key_t tags = path_extract_key0(comps);

    if (!tags)
    {
        g_strfreev(comps);
        return -1;
    }

    f = get_files_list(DB, tags);
    t = get_tags_list(DB, tags);
    GList *old_f = f;
    f = filter_files_by_plugin_tags(plugin_tags_table, f);
    if (old_f != f)
    {
        GList *temp = NULL;
        // filter the tags
        LL(t, it)
        {
            Tag *this_tag = it->data;
            file_id_t tid = tag_id(this_tag);
            LL(f, itt)
            {
                File *this_file = itt->data;
                if (file_has_tag(this_file, tid))
                {
                    temp = g_list_append(temp, this_tag);
                    break;
                }
            } LL_END
        } LL_END
        g_list_free(t);
        t = temp;
    }

    LL (tag_list_populators, it)
    {
        TagListPopulator *p = (TagListPopulator*)it->data;
        GList *populate_tags = PMCALL(p, populate, f);
        GList *path_tags = g_hash_table_lookup(plugin_tags_table, plugin_name(p));

        GList *filtered = NULL;
        if (path_tags)
        {
            LL (populate_tags, itt)
            {
                Tag *populate_tag = itt->data;
                const char *populate_tag_name = tag_name(populate_tag);
                gboolean match = FALSE;
                LL(path_tags, ittt)
                {
                    Tag *path_tag = ittt->data;
                    debug("readdir comparing %s and %s", populate_tag_name, tag_name(path_tag));
                    if (g_strcmp0(populate_tag_name, tag_name(path_tag)) == 0)
                    {
                        match = TRUE;
                        break;
                    }
                } LL_END
                match = match || g_strv_contains((const char * const *) comps, populate_tag_name);

                if (!match)
                {
                    filtered = g_list_append(filtered, populate_tag);
                }
                else
                {
                    tag_destroy0(populate_tag);
                }
            } LL_END
            g_list_free(populate_tags);
        }
        else
        {
            filtered = populate_tags;
        }
        t = g_list_concat(t, filtered);
    } LL_END

    GList *tmp = stage_list_position(STAGE, tags);
    LL(tmp, it)
    {
        s = g_list_prepend(s, retrieve_tag(DB, TO_S(it->data)));
    } LL_END
    g_list_free(tmp);

    seen = g_hash_table_new(g_str_hash, g_str_equal);
    LL(f, it)
    {
        if (it->data)
        {
            File *seen_file = g_hash_table_lookup(seen, file_name(it->data));
            if (seen_file && (seen_file != it->data))
            {
                prefixed_files = g_list_prepend(prefixed_files, it->data);
                /* maybe better to do this one once, but hey */
                prefixed_files = g_list_prepend(prefixed_files, seen_file);
            }
            else
            {
                (void)g_hash_table_insert(seen, (gpointer)file_name(it->data), it->data);
            }
        }
    } LL_END;

    {
        GList *seen_file_names = g_hash_table_get_keys(seen);
        LL(seen_file_names, it)
        {
            if (it->data)
            {
                File *seen_file = g_hash_table_lookup(seen, it->data);
                if (seen_file)
                {
                    if (file_stat(seen_file, &statbuf) >= 0)
                    {
                        list_file(it->data, filler, buffer, &statbuf);
                    }
                    else
                    {
                        error("Couldn't stat file %s in readdir", (char*)it->data);
                    }
                }
                else
                {
                    error("Looked up NULL file in readdir `seen' table");
                }
            }
            else
            {
                error("Got NULL in readdir `seen_file_names'");
            }
        } LL_END;
        g_list_free(seen_file_names);
    }

    seen_duplicates = g_hash_table_new(g_direct_hash, g_direct_equal);
    LL(prefixed_files, it)
    {
        File *seen_file = g_hash_table_lookup(seen_duplicates, (gpointer)it->data);
        if (!seen_file)
        {
            file_to_string(it->data, fname);
            file_stat(it->data, &statbuf);
            list_file(fname, filler, buffer, &statbuf);
            (void)g_hash_table_insert(seen_duplicates, (gpointer)it->data, it->data);
        }
    } LL_END;
    g_hash_table_destroy(seen_duplicates);

    combined_tags = g_list_concat(t, s);
    LL(combined_tags, it)
    {
        Tag *current_tag = (Tag*)it->data;
        tag_stat(current_tag, &statbuf);
        tag_to_string1(current_tag, fname, MAX_FILE_NAME_LENGTH);
        if (fname[0])
        {
            AbstractFile *seen_file = g_hash_table_lookup(seen, fname);
            if (!seen_file)
            {
                list_file(fname, filler, buffer, &statbuf);
                (void)g_hash_table_insert(seen, fname, current_tag);
            }
            else
            {
                /* XXX: If the previously seen object is a File, then we will
                 * print out the prefixed name of the file. otherwise we just
                 * don't print out the name again
                 */
                if (file_is_file(seen_file))
                {
                    file_to_string(seen_file, fname);
                    list_file(fname, filler, buffer, NULL);
                }
            }
        }
        else
        {
            warn("readdir:Can't list overlong tag name");
        }

        SLL(current_tag->aliases, ita)
        {
            AbstractFile *seen_file = g_hash_table_lookup(seen, ita->data);
            if (!seen_file)
            {
                list_file((char*)ita->data, filler, buffer, NULL);
                g_hash_table_insert(seen, ita->data, current_tag);
            }
        } SLL_END;
    } LL_END;

    READDIR_END:
    g_strfreev(comps);
    if (plugin_tags_table)
    {
        g_hash_table_destroy(plugin_tags_table);
    }
    g_hash_table_destroy(seen);
    key_destroy(tags);
    g_list_free(f);
    g_list_free(prefixed_files);
    g_list_free_full(combined_tags, (GDestroyNotify) temp_tags_destroy);
    return res;
}

GList *filter_files_by_plugin_tags (GHashTable *plugin_tags_table, GList *files)
{
    if (plugin_tags_table && g_hash_table_size(plugin_tags_table) > 0)
    {
        HL (plugin_tags_table, _, k, v)
        {
            GList *plugin_tags = g_hash_table_lookup(plugin_tags_table, k);
            if (plugin_tags)
            {
                TagListPopulator *p = plugin_manager_get_plugin(PM, TagListPopulator, k);
                GList *temp = PMCALL(p, filter, plugin_tags, files);
                g_list_free(files);
                files = temp;
            }
            if (!files)
            {
                break;
            }
        } HL_END
    }
    return files;
}

%(op listxattr path list size)
{
    File *f = path_to_file(path);
    char fname[MAX_FILE_NAME_LENGTH];
    int res = -ENOENT;
    if (f)
    {
        GString *s = g_string_sized_new(24); /* XXX: What's a good value? No idea. */
        GList *tags = file_tag_ids(f);
        size_t real_size = 0;

        LL(tags, it)
        {
            file_id_t tag_id = TO_S(it->data);
            Tag *t = retrieve_tag(DB, tag_id);
            tag_to_string1(t, fname, MAX_FILE_NAME_LENGTH);
            if (fname[0])
            {
                real_size += strlen(fname);
                real_size += 1 + strlen(XATTR_PREFIX);
                (void)g_string_append_printf(s, XATTR_PREFIX"%s", fname);
                (void)g_string_append_c(s, 0);
            }
            else
            {
                warn("listxattr:Overlong tag name");
            }
        } LL_END;

        {
            char *realpath = file_realpath(f);
            char *l = "";
            ssize_t list_size = llistxattr(realpath, l, 0);
            if (list_size >= 0)
            {
                l = g_try_malloc(list_size);
                if (l)
                {
                    ssize_t real_list_size = llistxattr(realpath, l, list_size);
                    if (real_list_size > 0)
                    {
                        (void)g_string_append_len(s, l, real_list_size);
                    }
                    real_size += real_list_size;
                }
                else
                {
                    res = -ERANGE;
                }
                g_free(l);
            }
            g_free(realpath);
        }

        if (list && size > 0)
        {
            if (size < real_size)
            {
                res = -ERANGE;
            }
            else
            {
                memmove(list, s->str, real_size);
                res = (int)real_size;
            }
        }
        else
        {
            res = (int)real_size;
        }
        g_list_free(tags);
        g_string_free(s, FALSE);
    }
    return res;
}

%(op getxattr path name value size)
{
    int res = -ENOENT;
    tagdb_begin_transaction(DB);
    Tag *t = is_directory(path);
    if (t)
    {
        if (tag_is_plugin_tag(t))
        {
            plugin_tag_destroy((PluginTag*)t);
        }
        res = -ENOATTR;
    }
    else
    {
        File *f = path_to_file(path);
        if (f)
        {
            if (strncmp(XATTR_PREFIX, name, strlen(XATTR_PREFIX)) == 0)
            {
                name = name + strlen(XATTR_PREFIX);
                if (strchr(name, '/'))
                {
                    res = -EINVAL;
                    goto END;
                }
                t = lookup_tag(DB, name);
                if (t) {
                    tagdb_value_t *val = file_tag_value(f, tag_id(t));
                    debug("tag value = %s", val);
                    if (val) {
                        size_t vallen = strlen(val);
                        if (value && size > vallen)
                        {
                            memmove(value, val, vallen);
                        }
                        res = vallen;
                    } else {
                        res = -ENOATTR;
                    }
                } else {
                    res = -ENOATTR;
                }
            }
            else
            {
                char *realpath = file_realpath(f);
                int stat = lgetxattr(realpath, name, value, size);
                if (stat < 0)
                {
                    res = -1 * errno;
                }
                else
                {
                    res = stat;
                }
                g_free(realpath);
            }
        }
    }
    tagdb_end_transaction(DB);
    END:
    return res;
}

%(op setxattr path name value size flags)
{
    /* XXX: `value' and `size' are not used */
    File *f = path_to_file(path);
    /*char value_buffer[size]; */
    int res = -ENOENT;
    Tag *t = NULL;
    if (f)
    {
        /* If there's a value, then we just ignore it. If the create flag is
         * given, then we add a tag if there isn't one and return error if there is one.
         * If the replace flag is given, then we return error if the tag isn't on the file
         * and return success if there is one.
         */
        if (strncmp(XATTR_PREFIX, name, strlen(XATTR_PREFIX)) == 0)
        {
            name = name + strlen(XATTR_PREFIX);
            if (strchr(name, '/'))
            {
                res = -EINVAL;
                goto END;
            }
            t = lookup_tag(DB, name);
            if (flags & XATTR_CREATE)
            {
                if (t)
                {
                    res = -EEXIST;
                    goto END;
                }
                else
                {
                    if (strlen(name) > 0)
                    {
                        t = tagdb_make_tag(DB, name);
                    }
                    else
                    {
                        res = -EINVAL;
                        goto END;
                    }
                }
            }
            else if ((flags & XATTR_REPLACE) && !t)
            {
                res = -ENOATTR;
                goto END;
            }
            else
            {
                if (strlen(name) > 0)
                {
                    t = tagdb_make_tag(DB, name);
                }
                else
                {
                    res = -EINVAL;
                    goto END;
                }
            }

            if ((flags & XATTR_REPLACE) && file_tag_value(f, tag_id(t)) == NULL)
            {
                res = -ENOATTR;
            }
            else
            {
                debug("value size = %ld", size);
                tagdb_value_t *temp = g_malloc0(size + 1);
                if (temp)
                {
                    memmove(temp, value, size);
                    add_tag_to_file(DB, f, tag_id(t), temp);
                    g_free(temp);
                    res = 0;
                }
                else
                {
                    res = -ENOSPC;
                }
            }
        }
        else
        {
            char *realpath = file_realpath(f);
            int stat = lsetxattr(realpath, name, value, size, flags);
            if (stat < 0)
            {
                res = -1 * errno;
            }
            else
            {
                res = 0;
            }
            g_free(realpath);
        }
    }
    END:
    return res;
}

%(op removexattr path name)
{
    File *f = path_to_file(path);
    int res = -ENOENT;
    Tag *t = NULL;
    if (f)
    {
        if (strncmp(XATTR_PREFIX, name, strlen(XATTR_PREFIX)) == 0)
        {
            name = name + strlen(XATTR_PREFIX);

            if (strlen(name) > 0)
            {
                t = lookup_tag(DB, name);
                if (t)
                {
                    remove_tag_from_file(DB, f, tag_id(t));
                }
                res = 0;
            }
            else
            {
                res = -EINVAL;
            }

        }
        else
        {
            char *realpath = file_realpath(f);
            int stat = lremovexattr(realpath, name);
            if (stat < 0)
            {
                res = -1 * errno;
            }
            else
            {
                res = 0;
            }
            g_free(realpath);
        }
    }
    return res;
}

_FileHandle *file_handle_new(int fd, File *fp)
{
    _FileHandle *fh = malloc(sizeof(_FileHandle));
    fh->fd = fd;
    fh->fp = fp;
    return fh;
}

void file_handle_destroy(_FileHandle* fh)
{
    free(fh);
}

%(subfs_component)
