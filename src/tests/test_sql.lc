#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "log.h"
#include "sql.h"
#include "private/sql.h"
#include "test.h"

#define TESTDIR_TEMPLATE "/tmp/sql_test.XXXXXX"
char TEST_DIRECTORY[] = TESTDIR_TEMPLATE;
char DB_NAME[128];

sqlite3 *DB;

%(test sql backup)
{
    sqlite3 *db;

    strcpy(TEST_DIRECTORY, TESTDIR_TEMPLATE);
    mkdtemp(TEST_DIRECTORY);
    sprintf(DB_NAME, "%s/sql.db", TEST_DIRECTORY);
    int sqlite_flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_FULLMUTEX;
    if (sqlite3_open_v2(DB_NAME, &db, sqlite_flags, NULL) != SQLITE_OK)
    {
        error("Couldn't open the database\n");
    }
    else
    {
        for (int i = 0; i < 10; i++)
        {
            database_backup(db);
            sprintf(DB_NAME, "%s/sql.db.bkp%03d", TEST_DIRECTORY, i);
            debug("Backing up %s", DB_NAME);
            CU_ASSERT_NOT_EQUAL(-1, open(DB_NAME, O_RDONLY));
        }

        sqlite3_close(db);
        sprintf(DB_NAME, "%s/sql.db", TEST_DIRECTORY);
        unlink(DB_NAME);

        for (int i = 0; i < 10; i++)
        {
            sprintf(DB_NAME, "%s/sql.db.bkp%03d", TEST_DIRECTORY, i);
            unlink(DB_NAME);
        }
        rmdir(TEST_DIRECTORY);
    }
}

%(setup sql_upgrade)
{
    strcpy(TEST_DIRECTORY, TESTDIR_TEMPLATE);
    mkdtemp(TEST_DIRECTORY);
    sprintf(DB_NAME, "%s/sql.db", TEST_DIRECTORY);
    int sqlite_flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_FULLMUTEX;
    if (sqlite3_open_v2(DB_NAME, &DB, sqlite_flags, NULL) != SQLITE_OK)
    {
        error("Couldn't open the database\n");
        abort();
    }
}

%(teardown sql_upgrade)
{
    database_clear_backups(DB);
    int res = sqlite3_close_v2(DB);
    if (res != SQLITE_OK)
    {
        error("Couldn't close the database");
    }
    unlink(DB_NAME);
    rmdir(TEST_DIRECTORY);
}

typedef struct _data {
    uint64_t f;
    uint64_t t;
    char *val;
} data;

%(test sql_upgrade 8_to_9_preserves_file_tag_values)
{
    char *tables =
    /* a table of tag names, ids, and default_values to set for files */
    "create table file_tag(file integer not null, tag integer not null, value blob,"
            " primary key (file,tag));"
            ;
    if (sql_exec(DB, tables) != SQLITE_OK)
    {
        CU_FAIL("Couldn't set up the database tables");
    }

    sqlite3_stmt *stmt;
    sql_prepare(DB, "insert into file_tag(file, tag, value) values(?,?,?)", stmt);
    _set_version0(DB, 8);
    int datasize = 3;
    data dat[] = {
        { 1, 3, "My data"},
        { 2, 4, "My Dota"},
        { 2, 5, "My Dita"}
    };
    for (int i = 0; i < datasize; i++)
    {
        sqlite3_reset(stmt);
        sqlite3_bind_int64(stmt, 1, dat[i].f);
        sqlite3_bind_int64(stmt, 2, dat[i].t);
        sqlite3_bind_blob(stmt, 3, dat[i].val, -1, SQLITE_TRANSIENT);
        sql_step(stmt);
    }
    sqlite3_finalize(stmt);

    int res = try_upgrade_db0(DB, 9);
    CU_ASSERT_EQUAL(res, DB_TRY_UPGRADE_SUCCESS);

    sql_prepare(DB, "select file, tag, value from file_tag", stmt);
    sqlite3_reset(stmt);
    while (sql_next_row(stmt) == SQLITE_ROW)
    {
        uint64_t file = sqlite3_column_int64(stmt, 0);
        uint64_t tag = sqlite3_column_int64(stmt, 1);
        const unsigned char *val = sqlite3_column_text(stmt, 2);
        for (int i = 0; i < datasize; i++)
        {
            if (dat[i].f == file && dat[i].t == tag)
            {
                CU_ASSERT_STRING_EQUAL(dat[i].val, val);
            }
            else
            {
                CU_FAIL("Couldn't find the entry");
            }
        }
    }
    sqlite3_finalize(stmt);
}

%(test sql_upgrade 7_to_8_preserves_default_values)
{
    char *tables =
    /* a table of tag names, ids, and default_values to set for files */
    "create table tag(id integer primary key, name varchar(255), default_value blob);";
    if (sql_exec(DB, tables) != SQLITE_OK)
    {
        CU_FAIL("Couldn't set up the database tables");
    }

    sqlite3_stmt *stmt;
    sql_prepare(DB, "insert into tag(id, name, default_value) values(?,?,?)", stmt);

    _set_version0(DB, 7);
    const char *names[][2] = {
        { "ammonite", "My data"},
        { "chorion", "My Dota"},
        { "instar", "My Dita"},
    };
    for (int i = 0; i < 3; i++)
    {
        sqlite3_reset(stmt);
        sqlite3_bind_int64(stmt, 1, i + 1);
        sqlite3_bind_text(stmt, 2, names[i][0], -1, SQLITE_TRANSIENT);
        sqlite3_bind_blob(stmt, 3, names[i][1], -1, SQLITE_TRANSIENT);
        sql_step(stmt);
    }
    sqlite3_finalize(stmt);

    int res = try_upgrade_db0(DB, 8);
    CU_ASSERT_EQUAL(res, DB_TRY_UPGRADE_SUCCESS);

    sql_prepare(DB, "select id, name, default_explanation from tag", stmt);
    sqlite3_reset(stmt);
    while (sql_next_row(stmt) == SQLITE_ROW)
    {
        uint64_t id = sqlite3_column_int64(stmt, 0);
        const unsigned char *name = sqlite3_column_text(stmt, 1);
        const unsigned char *default_explanation = sqlite3_column_text(stmt, 2);
        CU_ASSERT_STRING_EQUAL(names[id - 1][0], name);
        CU_ASSERT_STRING_EQUAL(names[id - 1][1], default_explanation);
    }
    sqlite3_finalize(stmt);
}

%(test sql_upgrade 6_to_7_preserves_subtags_with_names)
{
    const char * tables = "create table subtag(super integer, sub integer unique,"
        " foreign key (super) references tag(id),"
        " foreign key (sub) references tag(id));"
        "create table tag(id integer primary key,"
        " name varchar(255), default_value blob);";
    if (sql_exec(DB, tables) != SQLITE_OK)
    {
        CU_FAIL("Couldn't set up the database tables");
    }

    sqlite3_stmt *stmt;
    sqlite3_stmt *subtag_stmt;
    sql_prepare(DB, "insert into tag(id, name) values(?,?)", stmt);
    sql_prepare(DB, "insert into subtag(super, sub) values(?,?)", subtag_stmt);

    _set_version0(DB, 6);
    char name[32];
    uint64_t bases[] = {2, 3, 5, 7};
    const char *names[] = {
        [2] = "32.16.8.4.2",
        [4] = "32.16.8.4",
        [8] = "32.16.8",
        [16] = "32.16",
        [32] = "32",
        [3] = "48.24.12.6.3",
        [6] = "48.24.12.6",
        [12] = "48.24.12",
        [24] = "48.24",
        [48] = "48",
        [5] = "80.40.20.10.5",
        [80] = "80",
        [40] = "80.40",
        [20] = "80.40.20",
        [10] = "80.40.20.10",
        [7] = "112.56.28.14.7",
        [112] = "112",
        [56] = "112.56",
        [28] = "112.56.28",
        [14] = "112.56.28.14"
    };
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            sqlite3_reset(stmt);
            sqlite3_bind_int64(stmt, 1, bases[i] * (1 << j));
            g_snprintf(name, 32, "%"PRIu64, bases[i] * (1 << j));
            sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);
            sql_step(stmt);
            if (j > 0)
            {
                sqlite3_reset(subtag_stmt);
                sqlite3_bind_int64(subtag_stmt, 1, bases[i] * (1 << j));
                sqlite3_bind_int64(subtag_stmt, 2, bases[i] * (1 << (j - 1)));
                sql_step(subtag_stmt);
            }
        }
    }
    sqlite3_finalize(stmt);
    sqlite3_finalize(subtag_stmt);

    try_upgrade_db0(DB, 7);
    sql_prepare(DB, "select id, name from tag", stmt);
    sqlite3_reset(stmt);
    while (sql_next_row(stmt) == SQLITE_ROW)
    {
        uint64_t id = sqlite3_column_int64(stmt, 0);
        const unsigned char *tag_name = sqlite3_column_text(stmt, 1);
        CU_ASSERT_STRING_EQUAL(names[id], tag_name);
    }
    sqlite3_finalize(stmt);
}

%(run_tests)
