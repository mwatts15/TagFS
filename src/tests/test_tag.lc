#include <stdio.h>
#include "tag.h"
#include "test.h"
#include "util.h"
#include "log.h"

%(test Tag to_string_basic)
{
    char _buf[256];
    buffer_t buf = buffer_wrap(256, _buf);
    Tag *t = new_tag("a", 0, 0);
    CU_ASSERT_STRING_EQUAL("a", tag_to_string(t, buf));
    tag_destroy(t);
}

%(test Tag to_string_short_buffer)
{
    /* If the given buffer is too small, the to_string should
     * just fail and return null.
     * XXX: Maybe it should print out an error message...
     */
    char _buf[3];
    buffer_t buf = buffer_wrap(3, _buf);
    Tag *t = new_tag("aladdin", 0, 0);
    CU_ASSERT_EQUAL(0, tag_to_string(t, buf)[0]);
    tag_destroy(t);
}

%(test Tag to_string_short_buffer_static)
{
    /* Like the previous test, but with a static
     * buffer rather than a stack allocated
     */
    static char _buf[3];
    buffer_t buf = buffer_wrap(3, _buf);
    Tag *t = new_tag("aladdin", 0, 0);
    CU_ASSERT_EQUAL(0, tag_to_string(t, buf)[0]);
    tag_destroy(t);
}

%(test Tag to_string_short_buffer_heap)
{
    /* Like the previous test, but with a heap allocated
     * buffer rather than a stack allocated
     */
    char *_buf = malloc(3);
    buffer_t buf = buffer_wrap(3, _buf);
    Tag *t = new_tag("aladdin", 0, 0);
    CU_ASSERT_EQUAL(0, tag_to_string(t, buf)[0]);
    tag_destroy(t);
    g_free(_buf);
}

%(test Tag direct_locking_0)
{
    Tag *t = new_tag("a", 0, 0);
    tag_lock(t);
    CU_ASSERT_TRUE(lock_timed_out(tag_lock(t)));
    tag_unlock(t);
    tag_destroy(t);
}

%(test Tag direct_locking_1)
{
    Tag *t = new_tag("a", 0, 0);
    CU_ASSERT_FALSE(lock_timed_out(tag_lock(t)));
    tag_unlock(t);
    tag_destroy(t);
}

%(test Tag attempt_destroy_on_lock_fails)
{
    Tag *t = new_tag("a", 0, 0);
    tag_lock(t);
    CU_ASSERT_FALSE(tag_destroy(t));
    tag_unlock(t);
    tag_destroy(t);
}

%(test Tag tag_to_string_on_overlong_name_returns_NULL)
{
    /* TODO: Replace this test with a similar one that doesn't use subtags */
    #if 0
    Tag *prev = NULL;
    Tag *tags[86];
    char buf[MAX_FILE_NAME_LENGTH] = {0};

    for (int i = 0; i < 86; i++)
    {
        tags[i] = new_tag("a", 0, 0);

        if (G_LIKELY(prev))
        {
            tag_set_subtag(prev, tags[i]);
            prev = tags[i];
        }
    }

    CU_ASSERT_STRING_EQUAL(tag_to_string1(prev, buf, MAX_FILE_NAME_LENGTH), "");

    for (int i = 0; i < 86; i++)
    {
        tag_destroy(tags[i]);
    }
    #endif
}

int main ()
{
    log_open0(stdout, INFO);
    %(run_tests);
    log_close();
}


