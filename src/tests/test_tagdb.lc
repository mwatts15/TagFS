#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "test.h"
#include "util.h"
#include "tagdb.h"
#include "log.h"
#include "tagdb_util.h"

#define TESTDIR "/tmp/tagdb_test.XXXXXX"
char test_directory[] = TESTDIR;
char *db_name = NULL;
static int test_number = 0;

void insert_tag (TagDB *db, Tag *t);

void setup (void)
{
    /* 256 MB mmap file */
    log_open0(stdout, WARN);
    strcpy(test_directory, TESTDIR);
    mkdtemp(test_directory);
    db_name = g_strdup_printf("%s/sql.db", test_directory);
}

void teardown (void)
{
    if (unlink(db_name) != 0)
    {
        perror("teardown: Error with unlink");
    }
    if (rmdir(test_directory) != 0)
    {
        perror("teardown: Error with rmdir");
    }
    g_free(db_name);
    /*log_close();*/
    test_number++;
}

%(setup TagDB)
{
    setup();
}

%(teardown TagDB)
{
    teardown();
}


/* Added to avoid needing to create and destroy the db object in each test
 * TODO: Replace all with TagDB_too where possible and give the original a
 *       different name
 */
TagDB *DB;
%(setup TagDB_too)
{
    setup();
    DB = tagdb_new(db_name);
}

%(teardown TagDB_too)
{
    tagdb_destroy(DB);
    DB = NULL;
    teardown();
}

%(setup TagDB_util)
{
    setup();
}

%(teardown TagDB_util)
{
    teardown();
}

%(setup TagDB_SQL)
{
    setup();
}

%(teardown TagDB_SQL)
{
    teardown();
}

%(setup TagDB_startup)
{
    setup();
}

%(teardown TagDB_startup)
{
    teardown();
}

%(test TagDB_startup new_tag_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", TAGDB_INT_TYPE, 0);
    insert_tag(db, t);
    file_id_t id = tag_id(t);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    t = new_tag("tag2", TAGDB_INT_TYPE, 0);
    insert_tag(db, t);
    CU_ASSERT_GREATER_THAN(tag_id(t), id);
    tagdb_destroy(db);
}

%(test TagDB_startup new_file_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("tag");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = new_file("tag2");
    insert_file(db, f);
    CU_ASSERT_GREATER_THAN(file_id(f), id);
    tagdb_destroy(db);
}

%(test TagDB_startup files_have_their_tags_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", TAGDB_STR_TYPE, "default_value");

    insert_tag(db, t);
    insert_file(db, f);

    add_tag_to_file(db, f, tag_id(t), 0);


    file_id_t id = file_id(f);
    file_id_t tid = tag_id(t);

    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    tagdb_key_t k = key_new();
    key_push_end(k, tid);
    CU_ASSERT_TRUE(file_has_tags(f, k));
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB_startup no_file_on_new)
{

    TagDB *db = tagdb_new(db_name);
    tagdb_destroy(db);
    int r = open(db_name, O_RDONLY);
    CU_ASSERT_TRUE(r > 0);
}

%(test TagDB_startup file_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB_startup tag_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    Tag *f = new_tag("file", TAGDB_INT_TYPE, 0);
    insert_tag(db, f);
    file_id_t id = tag_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_tag(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB_startup file_size_doesnt_increase_on_load)
{
    /* Before being changed in schema version 3, files inserted as untagged
     * would artificially increase the size of the database because the
     * untagged state was represented by a NULL in the tag column of file_tag.
     *
     * I had a hunch that this happened during startup. It actually happened
     * when adding files through tagdb_fs, but this isn't a bad test anyway.
     */
    off_t initial_size;
    off_t final_size;
    struct stat buf;

    TagDB *db = tagdb_new(db_name);
    tagdb_destroy(db);

    stat(db_name, &buf);
    initial_size = buf.st_size;

    db = tagdb_new(db_name);
    tagdb_destroy(db);

    stat(db_name, &buf);
    final_size = buf.st_size;

    CU_ASSERT_EQUAL(initial_size, final_size);
}

%(test TagDB add_tag_to_file_before_file_insert)
{
    /* This is to make sure that the *File* isn't given
     * any tags and the DB doesn't include the file when
     * it hasn't been inserted.
     */
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", TAGDB_STR_TYPE, "default_value");

    insert_tag(db, t);

    add_tag_to_file(db, f, tag_id(t), 0);
    tagdb_key_t k = file_extract_key(f);
    GList *l = tagdb_tag_files(db, t);
    CU_ASSERT_TRUE(key_is_empty(k));
    CU_ASSERT_NULL(l);

    key_destroy(k);
    file_destroy(f);
    g_list_free(l);
    tagdb_destroy(db);
}

%(test TagDB add_tag_to_file_before_tag_insert)
{
    /* This is to make sure that the *File* isn't given
     * any tags and the DB doesn't include the file when
     * it hasn't been inserted.
     *
     * This test also ensures that the untagged sql query
     * that generates the untagged list is non-empty.
     */
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", TAGDB_STR_TYPE, "default_value");

    insert_file(db, f);

    add_tag_to_file(db, f, tag_id(t), 0);
    tagdb_key_t k = file_extract_key(f);
    GList *l = tagdb_untagged_items(db);
    CU_ASSERT_TRUE(key_is_empty(k));
    if (l)
    {
        CU_ASSERT_PTR_EQUAL(f, l->data);
    }
    else
    {
        CU_FAIL("The file list was NULL");
    }

    key_destroy(k);
    tag_destroy(t);
    g_list_free(l);
    tagdb_destroy(db);
}

%(test TagDB lookup_untagged_file_with_all_untagged)
{
    /* This is to make sure that the *File* isn't given
     * any tags and the DB doesn't include the file when
     * it hasn't been inserted.
     *
     * This test also ensures that the untagged sql query
     * that generates the untagged list is non-empty.
     */
    TagDB *db = tagdb_new(db_name);
    File *f = tagdb_make_file(db, "file");

    tagdb_key_t k = file_extract_key(f);
    CU_ASSERT_TRUE(key_is_empty(k));
    File *g = tagdb_lookup_file(db, k, file_name(f));
    CU_ASSERT_PTR_EQUAL(f, g);
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB lookup_file_with_one_tag)
{
    TagDB *db = tagdb_new(db_name);
    File *f = tagdb_make_file(db, "file");
    Tag *t = tagdb_make_tag(db, "a");
    add_tag_to_file(db, f, tag_id(t), NULL);
    tagdb_key_t k = file_extract_key(f);
    CU_ASSERT_FALSE(key_is_empty(k));
    File *g = tagdb_lookup_file(db, k, file_name(f));
    CU_ASSERT_PTR_EQUAL(f, g);
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB lookup_file_with_two_tags)
{
    TagDB *db = tagdb_new(db_name);
    File *f = tagdb_make_file(db, "file");
    Tag *t = tagdb_make_tag(db, "a");
    Tag *s = tagdb_make_tag(db, "b");

    add_tag_to_file(db, f, tag_id(t), NULL);
    add_tag_to_file(db, f, tag_id(s), NULL);
    tagdb_key_t k = file_extract_key(f);
    CU_ASSERT_FALSE(key_is_empty(k));
    File *g = tagdb_lookup_file(db, k, file_name(f));
    CU_ASSERT_PTR_EQUAL(f, g);
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB lookup_file_with_two_tags_by_one_tag)
{
    TagDB *db = tagdb_new(db_name);
    File *f = tagdb_make_file(db, "file");
    Tag *t = tagdb_make_tag(db, "a");
    Tag *s = tagdb_make_tag(db, "b");

    add_tag_to_file(db, f, tag_id(t), NULL);
    add_tag_to_file(db, f, tag_id(s), NULL);
    tagdb_key_t k = key_new();
    key_push_end(k, tag_id(s));
    File *g = tagdb_lookup_file(db, k, file_name(f));
    CU_ASSERT_PTR_EQUAL(f, g);
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB lookup_nonexistant_file)
{
    TagDB *db = tagdb_new(db_name);
    tagdb_key_t k = key_new();
    File *g = tagdb_lookup_file(db, k, "a;sdkfjlsjd;k.txt");
    CU_ASSERT_NULL(g);
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB insert_two_tags_with_shared_name_succeeeds_but_is_non_root)
{
    /* Inserting a new tag with the name of one already
     * inserted should succeed, but leave the original
     * tag in place as the one to look-up
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));
    tag_destroy(s);

    tagdb_destroy(db);
}

%(test TagDB_too delete_existing_file_restores_count)
{
    CU_ASSERT_EQUAL(tagdb_nfiles(DB), 0);
    File *f = tagdb_make_file(DB, "some_file.txt");
    CU_ASSERT_EQUAL(tagdb_nfiles(DB), 1);
    tagdb_delete_file(DB, f);
    CU_ASSERT_EQUAL(tagdb_nfiles(DB), 0);
}

%(test TagDB_too delete_existing_file_restores_untagged_items)
{
    GList *l = tagdb_untagged_items(DB);
    CU_ASSERT_NULL(l);
    File *f = tagdb_make_file(DB, "some_file.txt");
    l = tagdb_untagged_items(DB);
    CU_ASSERT_NOT_NULL(l);
    g_list_free(l);
    tagdb_delete_file(DB, f);
    l = tagdb_untagged_items(DB);
    CU_ASSERT_NULL(l);
    g_list_free(l);
}

%(test TagDB rename_root_tag_to_existing_fails)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "tag1");
    Tag *s = tagdb_make_tag(db, "tag2");
    set_tag_name(db, t, tag_name(s));
    Tag *maybe_t = lookup_tag(db, "tag1");
    Tag *maybe_s = lookup_tag(db, "tag2");
    CU_ASSERT_PTR_NOT_NULL_FATAL(maybe_t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(maybe_s);
    CU_ASSERT_PTR_NOT_EQUAL_FATAL(maybe_s, maybe_t);
    CU_ASSERT_PTR_NOT_EQUAL(t, maybe_s);
    CU_ASSERT_PTR_EQUAL(t, maybe_t);
    CU_ASSERT_PTR_EQUAL(s, maybe_s);
    tagdb_destroy(db);
}

%(test TagDB rename_root_tag_to_root_tag)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "tag1");
    set_tag_name(db, t, "tag2");
    Tag *old_t = lookup_tag(db, "tag1");
    Tag *maybe_t = lookup_tag(db, "tag2");
    CU_ASSERT_PTR_NOT_NULL_FATAL(maybe_t);
    CU_ASSERT_PTR_EQUAL(t, maybe_t);
    CU_ASSERT_NULL(old_t);
    tagdb_destroy(db);
}

int h1(void *ret, int num_cols, char **values, char **names)
{
    /* If there's any result, then we're good */
    int *v = (int*)ret;
    *v += 1;
    return 0;
}

%(test TagDB_SQL insert_untagged_makes_no_file_tag_entry)
{
    TagDB *db = tagdb_new(db_name);
    File *f = tagdb_make_file(db, "file");

    char qstring[256];
    sprintf(qstring, "SELECT * from file_tag where file=%lu", file_id(f));
    int res = -1;
    sqlite3_exec(db->sqldb, qstring, h1, &res, NULL);
    CU_ASSERT_EQUAL(-1, res);
    tagdb_destroy(db);
}

%(run_tests)
