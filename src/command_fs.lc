#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "params.h"
#include "tagdb.h"
#include "command.h"
#include "command_fs.h"
#include "util.h"

/** commands are written to the file to perform some action and the results, if
 * any, can be read back from the same file. Accesses to the file must be in
 * series. The command is written between a call to open and a call to close on
 * the command file. The result can be read in multiple calls open/close calls,
 * but any intervening calls to
 */
%(path_check path)
{
    return (is_command_path(path) || is_command_response_path(path));
}

/** Gets the key and the kind from a command file's path. If the *key is set to
 * NULL, then there has been a parsing error.
 */
void get_kind_and_key (const char *name, char **kind, char **key)
{
    /* move past COMMAND_BASENAME ":" in name */
    const char *start = name + COMMAND_BASENAME_LEN;
    if (start[0] != ':')
    {
        *kind = NULL;
        *key = NULL;
    }
    else
    {
        start = start + 1;

        const char *second_colon = strchr(start, ':');
        if (second_colon == NULL)
        {
            *kind = NULL;

            if (start[0] == 0)
            {
                *key = NULL;
            }
            else
            {
                *key = g_strdup(start);
            }
        }
        else
        {
            // check if either the kind or the key are empty strings
            if (second_colon == start || second_colon[1] == 0)
            {
                *kind = NULL;
                *key = NULL;
            }
            else
            {
                *kind = g_strndup(start, second_colon - start);
                *key = g_strdup(second_colon + 1);
            }
        }
    }
}

%(op create path mode f_info)
{
    // - convert the file name to a key, domain, and whether it is a request or response
    // - lookup any existing requests/responses
    // - if there is an existing request, then the request is opened
    int retstat = 0;
    if (is_command_response_path(path))
    {
        retstat = -1;
    }
    else
    {
        char *kind = NULL;
        char *key = NULL;
        get_kind_and_key(path, &kind, &key);
        if (key == NULL)
        {
            retstat = -1;
        }
        else
        {
            CommandRequest *req = command_manager_request_new(CM, kind, key);
            if (req)
                f_info->fh = TO_64(req);
            else
                retstat = -ENOENT;
        }
        g_free(kind);
        g_free(key);
    }
    return retstat;
}

%(op open path f_info)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key == NULL)
    {
        retstat = -1;
    }
    else
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr != NULL)
            {
                f_info->fh = TO_64(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr != NULL)
            {
                f_info->fh = TO_64(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op getattr path statbuf)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key)
    {
        statbuf->st_nlink = 1;
        statbuf->st_mode = 0755 | S_IFREG;
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            printf("key = %s. cr = %p\n", key, cr);
            if (cr)
            {
                statbuf->st_size = command_request_size(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr)
            {
                statbuf->st_size = command_response_size(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
    }
    else
    {
        retstat = -1;
    }
    g_free(kind);
    g_free(key);
    printf("getattr returning %d\n", retstat);
    return retstat;
}

%(op release path f_info)
{
    printf("releasing %s\n", path);
    return 0;
}

%(op truncate path newsize)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    GString *s = NULL;
    if (is_command_path(path))
    {
        CommandRequest *cr = command_manager_get_request(CM, key);
        if (cr)
        {
            s = cr->command_buffer;
        }
        else
        {
            retstat = -ENOENT;
        }
    }
    else
    {
        CommandResponse *cr = command_manager_get_response(CM, key);
        if (cr)
        {
            s = cr->result_buffer;
        }
        else
        {
            retstat = -ENOENT;
        }
    }

    if (retstat == 0)
    {
        g_string_set_size(s, newsize);
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op write path buf size offset fi)
{
    struct WriteParams wp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    if (is_command_path(path))
    {
        CommandRequest *cr = (CommandRequest*)fi->fh;
        if (cr)
        {
            retstat = command_write_request(cr, wp);
        }
    }
    else
    {
        CommandResponse *cr = (CommandResponse*)fi->fh;
        if (cr)
        {
            retstat = command_write_response(cr, wp);
        }
    }
    return retstat;
}

%(op read path buf size offset fi)
{
    struct ReadParams rp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    if (is_command_path(path))
    {
        CommandRequest *cr = (CommandRequest*)fi->fh;
        if (cr)
        {
            retstat = command_read_request(cr, rp);
        }
    }
    else
    {
        CommandResponse *cr = (CommandResponse*)fi->fh;
        if (cr)
        {
            retstat = command_read_response(cr, rp);
        }
    }
    return retstat;
}

%(op unlink path)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    printf("unlinking %s\n", path);
    get_kind_and_key(path, &kind, &key);
    if (key)
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr)
            {
                command_manager_handle(CM, cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr)
            {
                command_manager_response_destroy(CM, cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
    }
    else
    {
        retstat = -ENOENT;
    }
    return retstat;
}

%(subfs_component)
