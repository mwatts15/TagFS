#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "params.h"
#include "tagdb.h"
#include "command.h"
#include "command_fs.h"
#include "fs_util.h"
#include "util.h"

/** commands are written to the file to perform some action and the results, if
 * any, can be read back from the same file. Accesses to the file must be in
 * series. The command is written between a call to open and a call to close on
 * the command file. The result can be read in multiple calls open/close calls,
 * but any intervening calls to
 */

GHashTable *hiddens;
sem_t hiddens_lock;

%(path_check path)
{
    return (is_command_path(path) || is_command_response_path(path)
            || strncmp(fast_basename(path), ".fuse_hidden", 12) == 0);
}

%(subfs_init)
{
    sem_init(&hiddens_lock, 0, 1);
    hiddens = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
}

/** Gets the key and the kind from a command file's path. If the *key is set to
 * NULL, then there has been a parsing error.
 */
void get_kind_and_key (const char *name, char **kind, char **key)
{
    /* move past COMMAND_BASENAME ":" in name */
    const char *start = name + COMMAND_BASENAME_LEN;
    if (start[0] != ':')
    {
        *kind = NULL;
        *key = NULL;
    }
    else
    {
        start = start + 1;

        const char *second_colon = strchr(start, ':');
        if (second_colon == NULL)
        {
            *kind = NULL;

            if (start[0] == 0)
            {
                *key = NULL;
            }
            else
            {
                *key = g_strdup(start);
            }
        }
        else
        {
            // check if either the kind or the key are empty strings
            if (second_colon == start || second_colon[1] == 0)
            {
                *kind = NULL;
                *key = NULL;
            }
            else
            {
                *kind = g_strndup(start, second_colon - start);
                *key = g_strdup(second_colon + 1);
            }
        }
    }
}

%(op create path mode f_info)
{
    // - convert the file name to a key, domain, and whether it is a request or response
    // - lookup any existing requests/responses
    // - if there is an existing request, then the request is opened
    int retstat = 0;
    if (is_command_response_path(path))
    {
        retstat = -1;
    }
    else
    {
        char *kind = NULL;
        char *key = NULL;
        get_kind_and_key(path, &kind, &key);
        if (key == NULL)
        {
            retstat = -1;
        }
        else
        {
            CommandRequest *req = command_manager_request_new(CM, kind, key);
            if (req)
                f_info->fh = TO_64(req);
            else
                retstat = -ENOENT;
        }
        g_free(kind);
        g_free(key);
    }
    return retstat;
}

%(op open path f_info)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key == NULL)
    {
        retstat = -1;
    }
    else
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr != NULL)
            {
                f_info->fh = TO_64(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr != NULL)
            {
                f_info->fh = TO_64(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op getattr path statbuf)
{
    %(log);
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);

    if (key)
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr)
            {
                statbuf->st_size = command_request_size(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr)
            {
                statbuf->st_size = command_response_size(cr);
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        statbuf->st_nlink = 1;
        statbuf->st_mode = 0755 | S_IFREG;
    }
    else
    {
        sem_wait(&hiddens_lock);
        char *p = g_hash_table_lookup(hiddens, path);
        sem_post(&hiddens_lock);
        if (!p)
        {
            retstat = -1;
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op release path f_info)
{
    return 0;
}

%(op truncate path newsize)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    GString *s = NULL;
    if (is_command_path(path))
    {
        CommandRequest *cr = command_manager_get_request(CM, key);
        if (cr)
        {
            s = cr->command_buffer;
        }
        else
        {
            retstat = -ENOENT;
        }
    }
    else
    {
        CommandResponse *cr = command_manager_get_response(CM, key);
        if (cr)
        {
            s = cr->result_buffer;
        }
        else
        {
            retstat = -ENOENT;
        }
    }

    if (retstat == 0)
    {
        g_string_set_size(s, newsize);
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op write path buf size offset fi)
{
    struct WriteParams wp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    if (is_command_path(path))
    {
        CommandRequest *cr = (CommandRequest*)fi->fh;
        if (cr)
        {
            retstat = command_write_request(cr, wp);
        }
    }
    else
    {
        CommandResponse *cr = (CommandResponse*)fi->fh;
        if (cr)
        {
            retstat = command_write_response(cr, wp);
        }
    }
    return retstat;
}

%(op read path buf size offset fi)
{
    struct ReadParams rp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    if (is_command_path(path))
    {
        CommandRequest *cr = (CommandRequest*)fi->fh;
        if (cr)
        {
            retstat = command_read_request(cr, rp);
        }
    }
    else
    {
        CommandResponse *cr = (CommandResponse*)fi->fh;
        if (cr)
        {
            retstat = command_read_response(cr, rp);
        }
    }
    return retstat;
}

%(op getxattr path name value size)
{
    if (value && size > 0)
    {
        value[0] = 0;
    }
    return 0;
}

%(op rename old new)
{
    if (strncmp(fast_basename(new), ".fuse_hidden", 12) == 0)
    {
        sem_wait(&hiddens_lock);
        g_hash_table_insert(hiddens, g_strdup(new), g_strdup(old));
        sem_post(&hiddens_lock);
        return 0;
    }
    return -1;
}

int _unlink(const char *path)
{
    int retstat = -ENOENT;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key)
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr)
            {
                command_manager_handle(CM, cr);
                retstat = 0;
            }
        }
        else
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr)
            {
                command_manager_response_destroy(CM, key);
                retstat = 0;
            }
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op unlink path)
{
    int retstat = _unlink(path);
    if (!retstat)
    {
        return 0;
    }

    sem_wait(&hiddens_lock);
    char *real_path = g_hash_table_lookup(hiddens, path);
    if (real_path)
    {
        retstat = _unlink(real_path);
        g_hash_table_remove(hiddens, path);
    }
    sem_post(&hiddens_lock);
    return retstat;
}

%(subfs_component)
