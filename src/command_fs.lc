#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "params.h"
#include "tagdb.h"
#include "command.h"
#include "command_fs.h"
#include "fs_util.h"
#include "util.h"

/** commands are written to the file to perform some action and the results, if
 * any, can be read back from the same file. Accesses to the file must be in
 * series. The command is written between a call to open and a call to close on
 * the command file. The result can be read in multiple calls open/close calls,
 * but any intervening calls to
 */

GHashTable *hiddens;
sem_t hiddens_lock;

%(path_check path)
{
    if (is_command_path(path)
            || is_command_response_path(path)
            || is_command_error_path(path))
    {
        return TRUE;
    }
    else
    {
        sem_wait(&hiddens_lock);
        gpointer p = g_hash_table_lookup(hiddens, path);
        sem_post(&hiddens_lock);
        return !!p;
    }
}

%(subfs_init)
{
    sem_init(&hiddens_lock, 0, 1);
    hiddens = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
}

/** Gets the key and the kind from a command file's path. If the *key is set to
 * NULL, then there has been a parsing error.
 */
void get_kind_and_key (const char *name, char **kind, char **key)
{
    /* move past COMMAND_BASENAME ":" in name */
    const char *start = name + COMMAND_BASENAME_LEN;
    if (start[0] != ':')
    {
        *kind = NULL;
        *key = NULL;
    }
    else
    {
        start = start + 1;

        const char *second_colon = strchr(start, ':');
        if (second_colon == NULL)
        {
            *kind = NULL;

            if (start[0] == 0)
            {
                *key = NULL;
            }
            else
            {
                *key = g_strdup(start);
            }
        }
        else
        {
            // check if either the kind or the key are empty strings
            if (second_colon == start || second_colon[1] == 0)
            {
                *kind = NULL;
                *key = NULL;
            }
            else
            {
                *kind = g_strndup(start, second_colon - start);
                *key = g_strdup(second_colon + 1);
            }
        }
    }
}

%(op create path mode f_info)
{
    int retstat = -ENOENT;
    if (is_command_path(path))
    {
        if (strlen(path) >= MAX_FILE_NAME_LENGTH)
        {
            retstat = -ENAMETOOLONG;
        }
        else
        {
            char *kind = NULL;
            char *key = NULL;
            get_kind_and_key(path, &kind, &key);
            if (key != NULL)
            {
                CommandRequest *req = command_manager_request_new(CM, kind, key);
                if (req)
                {
                    f_info->fh = TO_64(req);
                    retstat = 0;
                }
            }
            g_free(kind);
            g_free(key);
        }
    }
    return retstat;
}

%(op open path f_info)
{
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key == NULL)
    {
        retstat = -1;
    }
    else
    {
        void *fh = NULL;
        if (is_command_path(path))
        {
            fh = &(command_manager_get_request(CM, key)->base);
        }
        else if (is_command_response_path(path))
        {
            fh = &(command_manager_get_response(CM, key)->base);
        }
        else if (is_command_error_path(path))
        {
            GError *err = command_manager_get_error(CM, key);
            fh = fmemopen(err->message, strlen(err->message), "r");
        }

        if (fh != NULL)
        {
            f_info->fh = TO_64(fh);
        }
        else
        {
            retstat = -ENOENT;
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op getattr path statbuf)
{
    %(log);
    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);

    if (key)
    {
        CommandRequestResponse *cr = NULL;
        if (!is_command_error_path(path))
        {
            if (is_command_path(path))
            {
                cr = &(command_manager_get_request(CM, key)->base);
            }
            else
            {
                cr = &(command_manager_get_response(CM, key)->base);
            }

            if (cr)
            {
                statbuf->st_size = command_size(cr);
                statbuf->st_nlink = 1;
                statbuf->st_mode = 0755 | S_IFREG;
            }
            else
            {
                retstat = -ENOENT;
            }
        }
        else
        {
            GError *err = command_manager_get_error(CM, key);
            if (err)
            {
                statbuf->st_size = strlen(err->message);
                statbuf->st_nlink = 1;
                statbuf->st_mode = 0755 | S_IFREG;
            }
            else
            {
                retstat = -ENOENT;
            }
        }
    }
    else
    {
        sem_wait(&hiddens_lock);
        char *p = g_hash_table_lookup(hiddens, path);
        sem_post(&hiddens_lock);
        if (!p)
        {
            retstat = -1;
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op release path f_info)
{
    if (is_command_error_path(path))
    {
        return fclose((FILE*)f_info->fh);
    }
    return 0;
}

%(op truncate path newsize)
{
    if (is_command_error_path(path))
    {
        return -1;
    }

    int retstat = 0;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    GString *s = NULL;
    CommandRequestResponse *cr = NULL;
    if (is_command_path(path))
    {
        cr = &(command_manager_get_request(CM, key)->base);
    }
    else
    {
        cr = &(command_manager_get_response(CM, key)->base);
    }

    if (cr)
    {
        s = command_buffer(cr);
    }
    else
    {
        retstat = -ENOENT;
    }

    if (retstat == 0)
    {
        g_string_set_size(s, newsize);
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op write path buf size offset fi)
{
    if (is_command_error_path(path))
    {
        return -1;
    }

    struct WriteParams wp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    CommandRequestResponse *cr = (CommandRequestResponse*)fi->fh;
    retstat = command_write(cr, wp);
    return retstat;
}

%(op read path buf size offset fi)
{
    struct ReadParams rp = {.buf = buf, .size = size, .offset = offset };
    int retstat = -ENOENT;
    if (!is_command_error_path(path))
    {
        CommandRequestResponse *cr = (CommandRequestResponse*)fi->fh;
        retstat = command_read(cr, rp);
    }
    else
    {
        FILE *err = (FILE*)fi->fh;
        int stat = 0;
        if ((stat = fseek(err, offset, SEEK_SET)))
        {
            return -1 * errno;
        }
        retstat = fread(buf, 1, size, err);
        if (retstat < 0)
        {
            retstat = -1 * errno;
        }
    }
    return retstat;
}

%(op getxattr path name value size)
{
    return -ENOTSUP;
}

%(op rename old new)
{
    if (strncmp(fast_basename(new), ".fuse_hidden", 12) == 0)
    {
        sem_wait(&hiddens_lock);
        g_hash_table_insert(hiddens, g_strdup(new), g_strdup(old));
        sem_post(&hiddens_lock);
        return 0;
    }
    return -1;
}

int _unlink(const char *path)
{
    int retstat = -ENOENT;
    char *kind = NULL;
    char *key = NULL;
    get_kind_and_key(path, &kind, &key);
    if (key)
    {
        if (is_command_path(path))
        {
            CommandRequest *cr = command_manager_get_request(CM, key);
            if (cr)
            {
                command_manager_handle(CM, cr);
                retstat = 0;
            }
        }
        else if (is_command_response_path(path))
        {
            CommandResponse *cr = command_manager_get_response(CM, key);
            if (cr)
            {
                command_manager_response_destroy(CM, key);
                retstat = 0;
            }
        }
        else if (is_command_error_path(path))
        {
            if (command_manager_get_error(CM, key))
            {
                command_manager_error_destroy(CM, key);
                retstat = 0;
            }
        }
    }
    g_free(kind);
    g_free(key);
    return retstat;
}

%(op unlink path)
{
    int retstat = _unlink(path);
    if (!retstat)
    {
        return 0;
    }

    sem_wait(&hiddens_lock);
    char *real_path = g_hash_table_lookup(hiddens, path);
    if (real_path)
    {
        retstat = _unlink(real_path);
        g_hash_table_remove(hiddens, path);
    }
    sem_post(&hiddens_lock);
    return retstat;
}

static int _readdir_list_file(fuse_fill_dir_t filler, void *buf, const char *name, const struct stat *statbuf)
{
    int res = 0;
    if (filler(buf, name, statbuf, 0))
    {
        error("command_fs_readdir: filler: error");
        res = 1;
    }
    return res;
}

#define list_file(__name, __filler, __buffer, __stat, res) \
if (_readdir_list_file((__filler), (__buffer), (const char*)(__name), (__stat)))\
{\
    res = -1;\
    goto READDIR_END;\
}

char *_command_file_name(char *buffer, const char *base, const char *kind, const char *key)
{
    strcpy(buffer, base);
    if (kind)
    {
        strcat(buffer, ":");
        if (strlen(kind) > MAX_FILE_NAME_LENGTH - COMMAND_BASENAME_LEN - 3)
        {
            buffer[0] = 0;
            return NULL;
        }
        strncat(buffer, kind, MAX_FILE_NAME_LENGTH - COMMAND_BASENAME_LEN - 3);
    }
    strcat(buffer, ":");
    size_t len = 0;
    if (kind)
    {
        len = MAX_FILE_NAME_LENGTH - COMMAND_BASENAME_LEN - 4 - strlen(kind);
    }
    else
    {
        len = MAX_FILE_NAME_LENGTH - COMMAND_BASENAME_LEN - 3;
    }

    if (strlen(key) > len)
    {
        buffer[0] = 0;
        return NULL;
    }

    strncat(buffer, key, len);
    return buffer;
}

%(op readdir path buffer filler offset f_info)
{
    char fname[MAX_FILE_NAME_LENGTH];
    GList *reqs = g_hash_table_get_keys(CM->requests);
    GList *resps = g_hash_table_get_keys(CM->responses);
    GList *errs = g_hash_table_get_keys(CM->errors);
    int retstat = 0;
    LL(reqs, it)
    {
        const char *key = it->data;
        CommandRequest *req = g_hash_table_lookup(CM->requests, key);
        const char *kind = NULL;
        if (strcmp(command_kind(req), "default") == 0)
        {
            kind = command_kind(req);
        }
        _command_file_name(fname, COMMAND_BASENAME + 1, kind, key);
        list_file(fname, filler, buffer, NULL, retstat);
    } LL_END

    LL(resps, it)
    {
        const char *key = it->data;
        _command_file_name(fname, COMMAND_RES_BASENAME + 1, NULL, key);
        list_file(fname, filler, buffer, NULL, retstat);
    } LL_END

    LL(errs, it)
    {
        const char *key = it->data;
        _command_file_name(fname, COMMAND_ERR_BASENAME + 1, NULL, key);
        list_file(fname, filler, buffer, NULL, retstat);
    } LL_END
    READDIR_END:
    g_list_free(reqs);
    g_list_free(resps);
    g_list_free(errs);
    return retstat;
}

%(subfs_component)
