#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "util.h"
#include "params.h"
#include "types.h"
#include "log.h"
#include "result_to_fs.h"
#include "search_fs.h"
#include "stage.h"
#include "tagdb.h"
#include "set_ops.h"
#include "query.h"
#include "path_util.h"
#include "subfs.h"

/* configuration variables */
int c_log_level = ERROR;
char *c_db_file_name = NULL;
char *c_log_file_name = NULL;
char *c_data_prefix = NULL;
int c_do_logging = FALSE;
int do_drop_db = FALSE;

%(tagfs_operations
        getattr
        readdir
        mkdir
        create
        unlink
        rename
        rmdir
        write
        read
        truncate
        open
        chown
        chmod);

%(op destroy user_data)
{
    %(log)
    debug("SAVING TO DATABASE : %s", DB->db_fname);
    tagdb_save(DB, DB->db_fname);
    tagdb_destroy(DB);
    stage_destroy(STAGE);
    log_close();
    g_free(FSDATA->copiesdir);
    g_free(FSDATA->log_file);
    g_free(FSDATA);
}

%(fuse_operations);

static GOptionEntry command_line_options[] =
{
  { "debug", 'g', 0, G_OPTION_ARG_INT, &c_log_level, "The default logging level", NULL },
  { "logging", 's', 0, G_OPTION_ARG_NONE, &c_do_logging, "Enable logging to a file", NULL },
  { "log-file", 'l', 0, G_OPTION_ARG_STRING, &c_log_file_name, "The log file", NULL },
  { "db-file", 'b', 0, G_OPTION_ARG_STRING, &c_db_file_name, "The database file", NULL },
  { "data-dir", 0, 0, G_OPTION_ARG_STRING, &c_data_prefix, "Location of the data directory", NULL },
  { "drop-db", 0, 0, G_OPTION_ARG_NONE, &do_drop_db, "Delete the entire database. Retains file content, but will be overwritten upon further use.", NULL},
  {NULL},
};

void process_options (int *argc_ptr, char ***argv_ptr)
{
    GError *error = NULL;
    GOptionContext *context;

    context = g_option_context_new("- mount a tagfs file system");
    g_option_context_set_ignore_unknown_options(context, TRUE);
    g_option_context_add_main_entries(context, command_line_options, NULL);

    if (!g_option_context_parse(context, argc_ptr, argv_ptr, &error))
    {
      g_print("option parsing failed: %s\n", error->message);
      exit(1);
    }
    g_option_context_free(context);
}
/* Eats a relative path and spits out one relative to the x */
char *absolutize(const char *cwd, char **path)
{
    if (!g_path_is_absolute(*path))
    {
        char *tmp = *path;
        *path = g_build_filename(cwd, *path, NULL);
        g_free(tmp);
    }
    return *path;
}

int main (int argc, char **argv)
{
    int fuse_stat = 0;
    struct tagfs_state *tagfs_data = g_try_malloc(sizeof(struct tagfs_state));
    char *cwd = g_get_current_dir();

    if (!tagfs_data)
    {
        perror("Cannot alloc tagfs_data");
        abort();
    }

    process_options(&argc, &argv);
    char *prefix = (c_data_prefix != NULL)?g_strdup(c_data_prefix):g_build_filename(g_get_user_data_dir(), "tagfs", NULL);

    /* absolutize prefix if necessary */
    absolutize(cwd, &prefix);

    if (mkdir(prefix, (mode_t) 0755) && errno != EEXIST)
    {
        perror("could not make data directory");
    }

    if (c_do_logging)
    {
        tagfs_data->log_file = (c_log_file_name==NULL)?g_build_filename(prefix, "tagfs.log", NULL):g_strdup(c_log_file_name);
        /* absolutize log_file if necessary */
        absolutize(cwd, &tagfs_data->log_file);

        log_open(tagfs_data->log_file, c_log_level);
    }

    char *db_fname = NULL;
    if (c_db_file_name)
    {
        db_fname = g_strdup(c_db_file_name);
        debug("cwd = %s", cwd);
        absolutize(cwd, &db_fname);
    }
    else
    {
        debug("prefix = %s", prefix);
        db_fname = g_build_filename(prefix, "tagfs.db", NULL);
    }
    tagfs_data->copiesdir = g_build_filename(prefix, "copies", NULL);

    debug("bloop bloop = %s", tagfs_data->copiesdir);

    if (mkdir(tagfs_data->copiesdir, (mode_t) 0755) && errno != EEXIST)
    {
        error("could not make copies directory");
        fprintf(stderr, "could not make copies directory\n");
        abort();
    }

    debug("argc = %d",argc);

    if (argc < 2)
    {
        error("Must provide mount point for %s");
        fprintf(stderr, "Must provide mount point for %s\n", argv[0]);
        abort();
    }

    info("tagfs_data->copiesdir = \"%s\"\n", tagfs_data->copiesdir);

    if (!tagfs_data->copiesdir)
    {
        fprintf(stderr,"couldn't open copies directory");
        abort();
    }

    int db_fd = open(db_fname, O_RDONLY);
    if (db_fd == -1)
    {
        tagfs_data->db = tagdb_new(db_fname);
    }
    else
    {
        close(db_fd);
        if (do_drop_db)
            tagfs_data->db = tagdb_new(db_fname);
        else
            tagfs_data->db = tagdb_load(db_fname);
    }

    /*tagfs_data->rqm = query_result_manager_new();*/
    tagfs_data->stage = new_stage();
    subfs_init();

    //tagfs_data->search_results = new_search_list();
    fprintf(stderr, "about to call fuse_main\n");
    fuse_stat = fuse_main(argc, argv, &%(operations_struct_name), tagfs_data);
    fprintf(stderr, "fuse_main returned %d\n", fuse_stat);
    g_free(prefix);
    g_free(cwd);
    return fuse_stat;
}
