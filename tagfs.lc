#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#include "util.h"
#include "params.h"
#include "types.h"
#include "log.h"
#include "result_to_fs.h"
#include "search_fs.h"
#include "stage.h"
#include "tagdb.h"
#include "set_ops.h"
#include "query.h"
#include "path_util.h"
#include "subfs.h"

static char *consistency_flag_file;

tagfs_operations%
getattr
readdir
mkdir
%%

%%%fuse_operations%%%

op%destroy user_data%
%log%
{
    log_msg("SAVING TO DATABASE : %s\n", DB->db_fname);
    tagdb_save(DB, DB->db_fname);
    tagdb_destroy(DB);
    log_close();
    /* and now we're all clean */
    toggle_tagfs_consistency();
}

void check_opt_arg (int position, int argc, char *argv[argc])
{
    if (position > argc)
    {
        fprintf(stderr, "must provide argument to %s\n", argv[position - 1]);
        abort();
    }
}

gboolean tagfs_is_consistent ()
{
    FILE *f = fopen(consistency_flag_file, "r");
    if (!f)
    {
        fopen(consistency_flag_file, "w");
        fputc('0', f);
        fclose(f);
        return FALSE;
    }
    return (fgetc(f) == '1' && fclose(f) == 0);
}

void toggle_tagfs_consistency ()
{
    printf("toggling consistency_flag_file\n");
    FILE *f = fopen(consistency_flag_file, "r+");
    int c = fgetc(f);
    int d;
    rewind(f);
    if (c == '0')
    {
        d = '1';
    }
    else
    {
        c = '1';
        d = '0';
    }
    printf("state %c\n",c);
    fputc(d, f);
    fclose(f);
}

#if 0
/* restores consistent state if we exited
   in error */
// TODO:fix this :(
void ensure_tagfs_consistency (struct tagfs_state *st)
{
    if (tagfs_is_consistent()) return;
    GList *files = get_files_list(st->db, "/");
    LL(files, it)
    {
        File *f = it->data;
        char *res = g_strdup_printf("%s/%ld", st->copiesdir, f->id);
        struct stat statbuf;
        if (lstat(res, &statbuf) == -1) delete_file(st->db, f);
        LL_END;
    }
    toggle_tagfs_consistency();
}
#endif

static GOptionEntry command_line_options[] =
{
  { "debug", 'g', 0, G_OPTION_ARG_INT, &_log_level, "The default logging level", NULL },
};

int main (int argc, char **argv)
{
    int fuse_stat = 0;
    struct tagfs_state *tagfs_data = g_try_malloc(sizeof(struct tagfs_state));

    if (!tagfs_data)
    {
        perror("Cannot alloc tagfs_data");
        abort();
    }

    log_open("tagfs.log", 0);

    char *prefix = g_build_filename(g_get_user_data_dir(), "tagfs", NULL);
    char *db_fname = g_build_filename(prefix, "tagfs.db", NULL);
    tagfs_data->log_file = g_build_filename(prefix, "tagfs.log", NULL);
    tagfs_data->copiesdir = g_build_filename(prefix, "copies", NULL);
    //consistency_flag_file = g_build_filename(prefix, "tagfs.clean", NULL);
    tagfs_data->debug = FALSE;

    /*
     *char *new_argv[argc];
     *int new_argc = proc_options(argc, new_argv, argv, tagfs_data);
     */

    if (mkdir(prefix, (mode_t) 0755) && errno != EEXIST)
        log_error("could not make data directory");
    if (mkdir(tagfs_data->copiesdir, (mode_t) 0755) && errno != EEXIST)
        log_error("could not make copies directory");
    if (argc < 2)
    {
        fprintf(stderr, "Must provide mount point for %s\n", argv[0]);
        abort();
    }

    //char mountpath[PATH_MAX];
    tagfs_data->mountdir = realpath(argv[1], NULL);

    log_msg("tagfs_data->copiesdir = \"%s\"\n", tagfs_data->copiesdir);
    log_msg("tagfs_data->mountdir = \"%s\"\n", tagfs_data->mountdir);

    if (!(tagfs_data->copiesdir && tagfs_data->mountdir))
    {
        log_msg("couldn't open required directories");
        abort();
    }

    int db_fd = open(db_fname, O_RDONLY);
    if (db_fd == -1)
    {
        tagfs_data->db = tagdb_new(db_fname);
    }
    else
    {
        close(db_fd);
        tagfs_data->db = tagdb_load(db_fname);
    }
    //ensure_tagfs_consistency(tagfs_data);
    /* at this point, we're guaranteed consistency.
       however, we know that they fs may change while mounted so we say that
       the system state is inconsistent at this point */
    //toggle_tagfs_consistency();

    tagfs_data->rqm = query_result_manager_new();
    tagfs_data->stage = new_stage();
    subfs_init();

    tagfs_data->search_results = new_search_list();
    fprintf(stderr, "about to call fuse_main\n");
    fuse_stat = fuse_main(argc, argv, &tagfs_oper, tagfs_data);
    fprintf(stderr, "fuse_main returned %d\n", fuse_stat);
    //g_free(consistency_flag_file);
    return fuse_stat;
}
