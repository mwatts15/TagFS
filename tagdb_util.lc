#include "log.h"
#include "tag.h"
#include "tagdb.h"
#include "set_ops.h"
#include "tagdb.h"
#include "tagdb_util.h"
#include "util.h"

struct agg_children_data
{
    TagDB *db;
    GList *res;
};

void agg_tag_files (Tag *t, gpointer data)
{
    struct agg_children_data *d = data;
    GList *l = file_cabinet_get_drawer_l(d->db->files, tag_id(t));
    d->res = g_list_concat(d->res, l);
}

void agg_tag_tags (Tag *t, gpointer data)
{
    struct agg_children_data *d = data;
    d->res = g_list_prepend(d->res, TO_SP(tag_id(t)));
}

GList *_tag_intersection(TagDB *db, tagdb_key_t key);
GList *get_tags_list (TagDB *db, tagdb_key_t key)
{
    %(log);

    GList *tags = NULL;
    if (key_is_empty(key))
    {
        tags = tagdb_tag_names(db);
    }
    else
    {
        tags = _tag_intersection(db, key);
    }

    GList *res = NULL;
    LL(tags, list)
    {
        int skip = 0;
        /* For skipping over entries that have already appeared
         * in the path
         */
        KL(key, i)
        {
            if (TO_S(list->data) == key_ref(key,i))
            {
                skip = 1;
            }
        } KL_END;

        if (!skip)
        {
            Tag *t = retrieve_tag(db, TO_S(list->data));
            if (t != NULL)
                res = g_list_prepend(res, t);
        }
    } LL_END;
    g_list_free(tags);
    return res;
}

GList *_tag_intersection(TagDB *db, tagdb_key_t key)
{
    int skip = 1;
    GList *res = NULL;
    KL(key, i)
    {
        file_id_t tid = key_ref(key, i);
        GList *this_drawer = file_cabinet_get_drawer_tags(db->files, tid);
        this_drawer = g_list_sort(this_drawer, (GCompareFunc) long_cmp);
        Tag *this_tag = retrieve_tag(db, tid);
        struct agg_children_data dat;
        dat.db = db;
        dat.res = NULL;
        tag_traverse(this_tag, agg_tag_tags, &dat);
        this_drawer = g_list_concat(this_drawer, dat.res);

        GList *tmp = NULL;
        if (skip)
        {
            tmp = g_list_copy(this_drawer);
        }
        else
        {
            tmp = g_list_intersection(res, this_drawer, (GCompareFunc) long_cmp);
        }

        g_list_free(this_drawer);
        g_list_free(res);
        res = tmp;
        skip = 0;
    } KL_END;

    return res;
}
/* Gets all of the files with the given tags
   as well as all of the tags below this one
   in the tree */
GList *get_files_list (TagDB *db, tagdb_key_t key)
{
    GList *res = NULL;
    int skip = 1;
    struct agg_children_data dat;

    if (key_is_empty(key))
    {
        debug("Getting untagged files");
        res = file_cabinet_get_drawer_l(db->files, UNTAGGED);
    }
    else
    {
        KL(key, i)
        {
            file_id_t tid = key_ref(key, i);
            GList *tmp = NULL;
            GList *files = NULL;
            Tag *this_tag = retrieve_tag(db, tid);

            dat.db = db;
            dat.res = NULL;

            tag_traverse(this_tag, agg_tag_files, &dat);
            files = dat.res;
            files = g_list_concat(files, file_cabinet_get_drawer_l(db->files, tid));
            files = g_list_sort(files, (GCompareFunc) file_id_cmp);

            if (skip)
            {
                tmp = g_list_copy(files);
            }
            else
            {
                tmp = g_list_intersection(res, files, (GCompareFunc) file_id_cmp);
            }

            g_list_free(res);
            g_list_free(files);
            res = tmp;
            skip = 0;
        } KL_END;
    }

    return res;
}
