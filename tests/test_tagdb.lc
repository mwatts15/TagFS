#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include "test.h"
#include "util.h"
#include "tagdb.h"
#include "log.h"

#define TESTDIR "/tmp/file_cabinet_test.XXXXXX"
char test_directory[] = TESTDIR;
char *db_name = NULL;
static int test_number = 0;

%(setup TagDB)
{
    /* 256 MB mmap file */
    char *b = g_strdup_printf("test_log%d.log", test_number);
    log_open(b, ERROR);
    free(b);
    strcpy(test_directory, TESTDIR);
    mkdtemp(test_directory);
    db_name = g_strdup_printf("%s/sql.db", test_directory);
}

%(teardown TagDB)
{
    if (unlink(db_name) != 0)
    {
        perror("teardown: Error with unlink");
    }
    if (rmdir(test_directory) != 0)
    {
        perror("teardown: Error with rmdir");
    }
    g_free(db_name);
    log_close();
    test_number++;
}

%(test TagDB no_file_on_new)
{

    TagDB *db = tagdb_new(db_name);
    tagdb_destroy(db);
    int r = open(db_name, O_RDONLY);
    CU_ASSERT_TRUE(r > 0);
}

%(test TagDB file_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB tag_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    Tag *f = new_tag("file", tagdb_int_t, 0);
    insert_tag(db, f);
    file_id_t id = tag_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_tag(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB new_tag_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", tagdb_int_t, 0);
    insert_tag(db, t);
    file_id_t id = tag_id(t);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    t = new_tag("tag2", tagdb_int_t, 0);
    insert_tag(db, t);
    CU_ASSERT_GREATER_THAN(tag_id(t), id);
    tagdb_destroy(db);
}

%(test TagDB new_file_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("tag");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = new_file("tag2");
    insert_file(db, f);
    CU_ASSERT_GREATER_THAN(file_id(f), id);
    tagdb_destroy(db);
}

%(test TagDB files_have_their_tags_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", tagdb_str_t, g_strdup("default_value"));

    insert_tag(db, t);

    add_tag_to_file(db, f, tag_id(t), 0);

    insert_file(db, f);

    file_id_t id = file_id(f);
    file_id_t tid = tag_id(t);

    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    tagdb_key_t k = key_new();
    key_push_end(k, tid);
    CU_ASSERT_TRUE(file_has_tags(f, k));
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_before_insert)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    tag_set_subtag(t, s);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag::blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_1)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag::blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_2)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_3)
{
    /* Although this is legally possible, it shouldn't be done
     * since the subtag relationship won't be known to the database
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);
    tag_set_subtag(t, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag::blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_4)
{
    /* This is one of the reasons why subtags shouldn't be established
     * only by the files -- it makes it possible to access a subtag
     * outside of its namespace.
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);
    tag_set_subtag(t, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_outside_of_namespace)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_NULL(lookup_tag(db, "blah"));

    tagdb_destroy(db);
}

%(test TagDB insert_two_tags_with_the_same_name_fails)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));

    tagdb_destroy(db);
    tag_destroy(s);
}

%(test TagDB insert_tags_with_shared_name_succeeds_when_one_is_the_child)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(t, s);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));
    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag::tag"));

    tagdb_destroy(db);
}

%(test TagDB insert_tags_with_shared_name_succeeds_when_in_different_namespaces)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *ns = new_tag("ns", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(ns, s);
    insert_tag(db, t);
    insert_tag(db, ns);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));
    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "ns::tag"));

    tagdb_destroy(db);
}

int main ()
{
   %(run_tests);
}
