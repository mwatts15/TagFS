#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include "test.h"
#include "util.h"
#include "tagdb.h"
#include "log.h"
#include "tagdb_util.h"

#define TESTDIR "/tmp/file_cabinet_test.XXXXXX"
char test_directory[] = TESTDIR;
char *db_name = NULL;
static int test_number = 0;

void setup (void)
{
    /* 256 MB mmap file */
    char *b = g_strdup_printf("test_log%d.log", test_number);
    log_open(b, ERROR);
    free(b);
    strcpy(test_directory, TESTDIR);
    mkdtemp(test_directory);
    db_name = g_strdup_printf("%s/sql.db", test_directory);
}

void teardown (void)
{
    if (unlink(db_name) != 0)
    {
        perror("teardown: Error with unlink");
    }
    if (rmdir(test_directory) != 0)
    {
        perror("teardown: Error with rmdir");
    }
    g_free(db_name);
    log_close();
    test_number++;
}

%(setup TagDB)
{
    setup();
}

%(teardown TagDB)
{
    teardown();
}

%(setup TagDB_util)
{
    setup();
}

%(teardown TagDB_util)
{
    teardown();
}

%(setup TagDB_SQL)
{
    setup();
}

%(teardown TagDB_SQL)
{
    teardown();
}

%(test TagDB no_file_on_new)
{

    TagDB *db = tagdb_new(db_name);
    tagdb_destroy(db);
    int r = open(db_name, O_RDONLY);
    CU_ASSERT_TRUE(r > 0);
}

%(test TagDB file_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB tag_created_on_load)
{
    TagDB *db = tagdb_new(db_name);
    Tag *f = new_tag("file", tagdb_int_t, 0);
    insert_tag(db, f);
    file_id_t id = tag_id(f);
    tagdb_destroy(db);
    db = tagdb_new(db_name);
    f = retrieve_tag(db, id);
    CU_ASSERT_NOT_NULL(f);
    tagdb_destroy(db);
}

%(test TagDB new_tag_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", tagdb_int_t, 0);
    insert_tag(db, t);
    file_id_t id = tag_id(t);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    t = new_tag("tag2", tagdb_int_t, 0);
    insert_tag(db, t);
    CU_ASSERT_GREATER_THAN(tag_id(t), id);
    tagdb_destroy(db);
}

%(test TagDB new_file_ids_increase_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("tag");
    insert_file(db, f);
    file_id_t id = file_id(f);
    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = new_file("tag2");
    insert_file(db, f);
    CU_ASSERT_GREATER_THAN(file_id(f), id);
    tagdb_destroy(db);
}

%(test TagDB files_have_their_tags_on_reload)
{
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", tagdb_str_t, g_strdup("default_value"));

    insert_tag(db, t);
    insert_file(db, f);

    add_tag_to_file(db, f, tag_id(t), 0);


    file_id_t id = file_id(f);
    file_id_t tid = tag_id(t);

    tagdb_destroy(db);

    db = tagdb_new(db_name);
    f = retrieve_file(db, id);
    tagdb_key_t k = key_new();
    key_push_end(k, tid);
    CU_ASSERT_TRUE(file_has_tags(f, k));
    key_destroy(k);
    tagdb_destroy(db);
}

%(test TagDB add_tag_to_file_before_file_insert)
{
    /* This is to make sure that the *File* isn't given
     * any tags and the DB doesn't include the file when
     * it hasn't been inserted.
     */
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", tagdb_str_t, g_strdup("default_value"));

    insert_tag(db, t);

    add_tag_to_file(db, f, tag_id(t), 0);
    tagdb_key_t k = file_extract_key(f);
    GList *l = tag_files(db, t);
    CU_ASSERT_TRUE(key_is_empty(k));
    CU_ASSERT_NULL(l);

    key_destroy(k);
    file_destroy(f);
    g_list_free(l);
    tagdb_destroy(db);
}

%(test TagDB add_tag_to_file_before_tag_insert)
{
    /* This is to make sure that the *File* isn't given
     * any tags and the DB doesn't include the file when
     * it hasn't been inserted.
     */
    TagDB *db = tagdb_new(db_name);
    File *f = new_file("file");
    Tag *t = new_tag("tag", tagdb_str_t, g_strdup("default_value"));

    insert_file(db, f);

    add_tag_to_file(db, f, tag_id(t), 0);
    tagdb_key_t k = file_extract_key(f);
    GList *l = tagdb_untagged_items(db);
    CU_ASSERT_TRUE(key_is_empty(k));
    CU_ASSERT_PTR_EQUAL(f, l->data);

    key_destroy(k);
    tag_destroy(t);
    g_list_free(l);
    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_before_insert)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    tag_set_subtag(t, s);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag"TPS"blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_1)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag"TPS"blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_2)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_3)
{
    /* Although this is legally possible, it shouldn't be done
     * since the subtag relationship won't be known to the database
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);
    tag_set_subtag(t, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag"TPS"blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_with_sub_tags_assoc_after_insert_4)
{
    /* This is one of the reasons why subtags shouldn't be established
     * only by the files -- it makes it possible to access a subtag
     * outside of its namespace.
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);
    tag_set_subtag(t, s);

    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "blah"));

    tagdb_destroy(db);
}

%(test TagDB lookup_tag_outside_of_namespace)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("blah", 0, 0);
    insert_tag(db, t);
    tag_set_subtag(t, s);
    insert_tag(db, s);

    CU_ASSERT_NULL(lookup_tag(db, "blah"));

    tagdb_destroy(db);
}

%(test TagDB insert_two_tags_with_the_same_name_fails)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));

    tagdb_destroy(db);
    tag_destroy(s);
}

%(test TagDB insert_tags_with_shared_name_succeeds_when_one_is_the_child)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(t, s);
    insert_tag(db, t);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));
    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "tag"TPS"tag"));

    tagdb_destroy(db);
}

%(test TagDB insert_tags_with_shared_name_succeeds_when_in_different_namespaces)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *ns = new_tag("ns", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(ns, s);
    insert_tag(db, t);
    insert_tag(db, ns);
    insert_tag(db, s);

    CU_ASSERT_PTR_EQUAL(t, lookup_tag(db, "tag"));
    CU_ASSERT_PTR_EQUAL(s, lookup_tag(db, "ns"TPS"tag"));

    tagdb_destroy(db);
}

%(test TagDB_util get_tags_list_empty_key)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = new_tag("tag", 0, 0);
    Tag *ns = new_tag("ns", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(ns, s);
    insert_tag(db, t);
    insert_tag(db, ns);
    insert_tag(db, s);
    tagdb_key_t j = key_new();

    GList *expected = NULL;
    expected = g_list_prepend(expected, t);
    expected = g_list_prepend(expected, ns);
    expected = g_list_prepend(expected, s);

    GList *tags = get_tags_list(db, j);
    LL(expected, it)
    {
        int idx = g_list_index(tags, it->data);
        CU_ASSERT_NOT_EQUAL(idx, -1);
    } LL_END;
    g_list_free(tags);
    g_list_free(expected);
    key_destroy(j);
    tagdb_destroy(db);
}

%(test TagDB_util get_tags_list_namespace)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *ns = new_tag("ns", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(ns, s);
    insert_tag(db, ns);
    insert_tag(db, s);
    tagdb_key_t j = key_new();
    key_push_end(j, tag_id(ns));

    GList *tags = get_tags_list(db, j);
    CU_ASSERT_EQUAL(g_list_length(tags), 1);
    int idx = g_list_index(tags, s);
    CU_ASSERT_NOT_EQUAL(idx, -1);
    g_list_free(tags);
    key_destroy(j);
    tagdb_destroy(db);
}

%(test TagDB_util get_files_list_namespace)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *ns = new_tag("ns", 0, 0);
    Tag *s = new_tag("tag", 0, 0);
    tag_set_subtag(ns, s);
    insert_tag(db, ns);
    insert_tag(db, s);
    tagdb_key_t j = key_new();
    key_push_end(j, tag_id(ns));

    GList *tags = get_tags_list(db, j);
    CU_ASSERT_EQUAL(g_list_length(tags), 1);
    int idx = g_list_index(tags, s);
    CU_ASSERT_NOT_EQUAL(idx, -1);
    g_list_free(tags);
    key_destroy(j);
    tagdb_destroy(db);
}

%(test TagDB make_tag)
{
    /* Inserting a new tag with the name of one already
     * inserted should fail without storing the new tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);

    Tag *ns = tag_parent(t);
    CU_ASSERT_NOT_NULL(ns);
    Tag *s = lookup_tag(db, "ns"TPS"tag");
    CU_ASSERT_PTR_EQUAL(t, s);
    s = lookup_tag(db, "ns");
    CU_ASSERT_PTR_EQUAL(ns, s);

    tagdb_destroy(db);
}

%(test TagDB delete_parent_tag_promotes_children)
{
    /* Deleting a parent tag must then allow us to lookup the tag as a base tag
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    Tag *ns = tag_parent(t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns);
    delete_tag(db, ns);
    Tag *t_also = lookup_tag(db, "tag");
    CU_ASSERT_PTR_EQUAL(t_also, t);

    tagdb_destroy(db);
}

%(test TagDB delete_parent_tag_evacuates_old_paths)
{
    /* Ensure that the old path isn't available for lookup
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    Tag *ns = tag_parent(t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns);
    delete_tag(db, ns);
    Tag *old_t = lookup_tag(db, "ns"TPS"tag");
    CU_ASSERT_NULL(old_t);

    tagdb_destroy(db);
}

%(test TagDB delete_tag_renders_inaccesible)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns1"TPS"ns2"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    Tag *ns1 = tag_parent(tag_parent(t));
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns1);
    delete_tag(db, ns1);

    Tag *not_here = lookup_tag(db, "ns1");
    CU_ASSERT_NULL(not_here);

    tagdb_destroy(db);
}

%(test TagDB child_tag_doesnt_show)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns1"TPS"ns2"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    Tag *ns1 = tag_parent(tag_parent(t));
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns1);
    delete_tag(db, ns1);

    Tag *not_here = lookup_tag(db, "tag");
    CU_ASSERT_NULL(not_here);

    tagdb_destroy(db);
}

%(test TagDB remove_tag_promotes_child)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    Tag *ns = tag_parent(t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns);
    remove_tag(db, ns);
    Tag *t_also = lookup_tag(db, "tag");
    CU_ASSERT_PTR_EQUAL(t_also, t);

    tag_destroy(ns);
    tagdb_destroy(db);
}

%(test TagDB remove_tag_fails_with_conflicting_name)
{
    /* The distinction between an existing tag without a namespace
     * and a tag formerly having a namespace is assumed to still
     * exist, so rather than either joining the post-namespace tag
     * with the never-namespaced or making the post-namespaced
     * inaccessible by name, we instead alter the name and allow
     * the user to subsequently change it or to merge the tags
     * manually.
     */
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    Tag *s = tagdb_make_tag(db, "tag");
    CU_ASSERT_PTR_NOT_NULL_FATAL(t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(s);
    Tag *ns = tag_parent(t);
    CU_ASSERT_PTR_NOT_NULL_FATAL(ns);
    CU_ASSERT_EQUAL(remove_tag(db, ns), 0);
    tagdb_destroy(db);
}

%(test TagDB insert_parent_of_previously_inserted_tag_demotes_child)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "tag");
    Tag *ns = new_tag("ns", 0, 0);
    tag_set_subtag(ns, t);
    insert_tag(db, ns);
    Tag *not_here = lookup_tag(db, "tag");
    CU_ASSERT_NULL(not_here);

    tagdb_destroy(db);
}

int h1(void *ret, int num_cols, char **values, char **names)
{
    /* If there's any result, then we're good */
    int *v = (int*)ret;
    *v += 1;
    return 0;
}

%(test TagDB_SQL subtag_insert_on_make_tag)
{
    TagDB *db = tagdb_new(db_name);
    Tag *t = tagdb_make_tag(db, "ns"TPS"tag");
    Tag *ns = tag_parent(t);

    char qstring[256];
    sprintf(qstring, "SELECT * from subtag where super=%lu and sub=%lu", tag_id(ns), tag_id(t));
    int res = 0;
    sqlite3_exec(db->sqldb, qstring, h1, &res, NULL);
    CU_ASSERT_EQUAL(1, res);
    tagdb_destroy(db);
}

int main ()
{
   %(run_tests);
}
